<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2026å…ƒæ—¦å¿«ä¹ - æµé‡‘æ˜Ÿäº‘ä¿®å¤ç‰ˆ</title>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=ZCOOL+XiaoWei&family=Playfair+Display:ital,wght@1,900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; touch-action: none; }
        /* èƒŒæ™¯è°ƒæ·±ï¼Œçªå‡ºæ˜Ÿäº‘å…‰æ„Ÿ */
        #container { position: relative; width: 100vw; height: 100vh; background: radial-gradient(circle at center, #12051c 0%, #000000 80%); }
        
        #title-container {
            position: absolute; top: 10%; width: 100%; text-align: center; pointer-events: none; z-index: 100;
        }

        #main-title {
            font-weight: normal; margin: 0; padding: 0 10px;
            color: transparent;
            /* è°ƒæ•´æ–‡å­—æ¸å˜è‰²ä»¥åŒ¹é…æ–°çš„æ˜Ÿäº‘èƒŒæ™¯ */
            background-image: linear-gradient(135deg, #FFFFFF 10%, #FFD700 40%, #ff8c00 70%, #ba55d3 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            background-clip: text;
            filter: drop-shadow(0px 2px 10px rgba(255, 215, 0, 0.3));
            animation: artisticShimmer 6s linear infinite alternate;
        }

        #main-title .year {
            font-family: 'Playfair Display', serif; font-weight: 900;
            font-size: clamp(3.5rem, 15vw, 6rem); display: block; line-height: 1;
        }

        #main-title .bless-1 { 
            font-family: 'Ma Shan Zheng', cursive; 
            font-size: clamp(3rem, 13vw, 5.5rem); 
            display: block; 
            margin-top: 5px;
            line-height: 1.2;
            padding-bottom: 25px;
        }
        
        #main-title .bless-2 { 
            font-family: 'ZCOOL XiaoWei', serif;
            font-size: clamp(1rem, 4.5vw, 1.8rem); display: block; letter-spacing: 0.25em; color: #e0c080;
        }

        @keyframes artisticShimmer { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }

        #info-instructions {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.7); background: rgba(40, 10, 60, 0.6); 
            padding: 8px 25px; border-radius: 50px; font-size: 0.75rem; z-index: 100; white-space: nowrap;
            border: 1px solid rgba(255, 215, 0, 0.2); backdrop-filter: blur(5px);
        }
        #video-input { display: none; }
    </style>
</head>
<body>
    <div id="title-container">
        <h1 id="main-title">
            <span class="year">2026</span>
            <span class="bless-1">å…ƒæ—¦å¿«ä¹</span>
            <span class="bless-2">å¤©å¤©å¼€å¿ƒï¼Œå­¦ä¸šæœ‰æˆ</span>
        </h1>
    </div>

    <div id="container">
        <div id="info-instructions">æ­£åœ¨æ±‡èšæµé‡‘æ˜Ÿäº‘...</div>
        <video id="video-input" playsinline></video>
    </div>

    <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        
        let scene, camera, renderer, particleSystem, mainGroup, imageGroup;
        // ä½¿ç”¨ TypedArray å­˜å‚¨èµ·å§‹å’Œç›®æ ‡ä½ç½®ï¼Œè¿™æ˜¯æ€§èƒ½å…³é”®
        let startPosArr, targetPosArr;
        let morphFactor = 0, targetMorph = 0;
        let lastAIrun = 0;

        // å¹³è¡¡ç‚¹ï¼šæ¯”ä¸Šä¸ªç‰ˆæœ¬å¤šï¼Œæ¯”æœ€åˆç‰ˆæœ¬å°‘ï¼Œé…åˆå…‰æ™•æè´¨è¶³å¤Ÿåä¸½
        const COUNT = isMobile ? 2800 : 5000;
        const IMG_COUNT = 10;

        // åˆ›å»ºæŸ”ç„¦å…‰æ™•è´´å›¾ï¼Œè®©ç²’å­çœ‹èµ·æ¥æ›´å¤§æ›´è½¯
        function createSoftSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.15, 'rgba(255,240,200,0.9)'); // æš–å…‰æ ¸å¿ƒ
            grad.addColorStop(0.4, 'rgba(220,180,80,0.4)');   // é‡‘è‰²å…‰æ™•
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            // ç›¸æœºæ‹‰è¿œä¸€ç‚¹ï¼Œçœ‹æ¸…å…¨è²Œ
            camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 1, 800);
            camera.position.z = 90;

            renderer = new THREE.WebGLRenderer({ antialias: !isMobile, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio, 1.5));
            document.getElementById('container').appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            // --- âœ… å›¾ç‰‡å›¾å±‚å›å½’ ---
            imageGroup = new THREE.Group();
            mainGroup.add(imageGroup);
            const loader = new THREE.TextureLoader();
            // é¢„åŠ è½½ä¸€å¼ é»˜è®¤å›¾é˜²æ­¢ç©ºç™½
            const defaultTex = createSoftSprite(); 

            for(let i=1; i<=IMG_COUNT; i++) {
                // å¼‚æ­¥åŠ è½½ï¼ŒåŠ è½½å¤±è´¥åˆ™ä½¿ç”¨é»˜è®¤å…‰æ™•å ä½
                loader.load(`./mj/${i}.jpg`, 
                    (tex) => { if(imageGroup.children[i-1]) imageGroup.children[i-1].material.map = tex; },
                    undefined,
                    () => { console.warn(`Image ${i} failed load`); }
                );
                const mat = new THREE.MeshBasicMaterial({ map: defaultTex, transparent: true, opacity: 0, side: THREE.DoubleSide, depthWrite: false });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(9, 12), mat);
                // ç¯ç»•æ’åˆ—
                const angle = ((i-1) / IMG_COUNT) * Math.PI * 2;
                const radius = 40;
                mesh.position.set(Math.cos(angle) * radius, Math.sin(angle) * 5, Math.sin(angle) * radius);
                mesh.lookAt(0, 0, 0); 
                imageGroup.add(mesh);
            }
            // -----------------------

            const geo = new THREE.BufferGeometry();
            startPosArr = new Float32Array(COUNT * 3);
            targetPosArr = new Float32Array(COUNT * 3);
            const currentPositions = new Float32Array(COUNT * 3);
            const colors = new Float32Array(COUNT * 3);
            
            const colGold = new THREE.Color(0xffd700);
            const colOrange = new THREE.Color(0xff8c00);
            const colPurple = new THREE.Color(0x8a2be2);

            for(let i=0; i<COUNT; i++) {
                // --- âœ… æ–°çš„æœ‰æœºæ˜Ÿäº‘å½¢æ€ç®—æ³• ---
                // ä¸å†æ˜¯ç®€å•çš„çº¿æ¡ï¼Œè€Œæ˜¯åŸºäºæ¦‚ç‡åˆ†å¸ƒçš„äº‘å›¢
                let radius, angle, yOffset;
                const spread = Math.random();
                
                if (spread < 0.3) { // 30% æ ¸å¿ƒå¯†é›†åŒº
                    radius = Math.random() * 15;
                    angle = Math.random() * Math.PI * 2;
                    yOffset = (Math.random() - 0.5) * 8;
                } else { // 70% å¤–å›´æ—‹è‡‚åŒº
                    radius = 15 + Math.random() * 35;
                    // åŠ ä¸Šä¸€äº›æ­£å¼¦æ³¢æ‰°åŠ¨ï¼Œè®©æ—‹è‡‚æ›´è‡ªç„¶
                    angle = radius * 0.1 + Math.sin(radius * 0.2) + Math.random() * 0.5;
                    yOffset = Math.sin(angle * 2 + radius * 0.1) * 10 + (Math.random()-0.5) * 5;
                }

                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                startPosArr[i*3] = x;
                startPosArr[i*3+1] = yOffset;
                startPosArr[i*3+2] = z;
                
                // åˆå§‹åŒ–å½“å‰ä½ç½®
                currentPositions[i*3] = x; currentPositions[i*3+1] = yOffset; currentPositions[i*3+2] = z;

                // --- ç›®æ ‡ä½ç½®ï¼ˆæ•£å¼€çš„ç¹æ˜Ÿï¼‰---
                const rSpread = 60 + Math.random() * 60;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                targetPosArr[i*3] = rSpread * Math.sin(phi) * Math.cos(theta);
                targetPosArr[i*3+1] = rSpread * Math.sin(phi) * Math.sin(theta);
                targetPosArr[i*3+2] = rSpread * Math.cos(phi);

                // --- ä¸°å¯Œçš„è‰²å½©åˆ†å¸ƒ ---
                let finalColor;
                const distRatio = radius / 50;
                if (distRatio < 0.3) finalColor = colGold; // æ ¸å¿ƒé‡‘
                else if (distRatio < 0.7) finalColor = colGold.clone().lerp(colOrange, (distRatio-0.3)/0.4); // ä¸­å±‚æ©™
                else finalColor = colOrange.clone().lerp(colPurple, (distRatio-0.7)/0.3); // è¾¹ç¼˜ç´«

                // éšæœºå¢åŠ ä¸€äº›é«˜äº®ç™½æ˜Ÿ
                if(Math.random()>0.97) finalColor = new THREE.Color(0xFFFFFF);

                colors[i*3] = finalColor.r; colors[i*3+1] = finalColor.g; colors[i*3+2] = finalColor.b;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(currentPositions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: isMobile ? 2.5 : 1.8, // ç²’å­è°ƒå¤§ï¼Œé…åˆå…‰æ™•è´´å›¾
                map: createSoftSprite(),    // ä½¿ç”¨æŸ”ç„¦è´´å›¾
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.9,
                depthWrite: false           // å…³é—­æ·±åº¦å†™å…¥æå‡æ€§èƒ½
            });

            particleSystem = new THREE.Points(geo, material);
            mainGroup.add(particleSystem);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            
            // ç¼“åŠ¨
            morphFactor += (targetMorph - morphFactor) * 0.08;
            
            // ç¼“æ…¢è‡ªè½¬
            mainGroup.rotation.y += 0.001;
            // éšæ‰‹åŠ¿è½»å¾®æµ®åŠ¨
            mainGroup.position.y = Math.sin(time) * 2 * morphFactor;

            // --- âœ… å›¾ç‰‡æ˜¾ç¤ºé€»è¾‘å›å½’ ---
            if(imageGroup) {
                const imgOpacity = THREE.MathUtils.smoothstep(morphFactor, 0.3, 0.9);
                const imgScale = 0.8 + morphFactor * 0.3;
                imageGroup.children.forEach((mesh, idx) => {
                    mesh.material.opacity = imgOpacity;
                    mesh.scale.setScalar(imgScale);
                    // è®©å›¾ç‰‡ä¹Ÿè½»å¾®æµ®åŠ¨
                    mesh.position.y = Math.sin(time + idx) * 2;
                });
            }

            // --- é«˜æ€§èƒ½ç²’å­æ’å€¼ ---
            const posAttr = particleSystem.geometry.attributes.position;
            const currentArr = posAttr.array;
            for(let i=0; i<COUNT * 3; i+=3) {
                // ç›´æ¥åœ¨æ•°ç»„é—´è¿›è¡Œçº¿æ€§æ’å€¼ï¼Œä¸åšä»»ä½•é¢å¤–è®¡ç®—
                currentArr[i]   = startPosArr[i]   * (1 - morphFactor) + targetPosArr[i]   * morphFactor;
                currentArr[i+1] = startPosArr[i+1] * (1 - morphFactor) + targetPosArr[i+1] * morphFactor;
                currentArr[i+2] = startPosArr[i+2] * (1 - morphFactor) + targetPosArr[i+2] * morphFactor;
            }
            posAttr.needsUpdate = true;
            
            renderer.render(scene, camera);
        }

        async function startAI() {
            const info = document.getElementById('info-instructions');
            try {
                const hands = new Hands({ locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}` });
                // ä½¿ç”¨æœ€è½»é‡çº§æ¨¡å‹è®¾ç½®
                hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5 });

                hands.onResults(res => {
                    const now = Date.now();
                    // é™åˆ¶ AI æ›´æ–°é¢‘ç‡ä¸ºæ¯ç§’çº¦ 20 æ¬¡ï¼Œç»™æ¸²æŸ“ç•™è¶³æ—¶é—´
                    if(now - lastAIrun < 50) return;
                    lastAIrun = now;

                    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                        const h = res.multiHandLandmarks[0];
                        // ç®€åŒ–çš„å¼€åˆåˆ¤æ–­ï¼šæ¯”è¾ƒæŒ‡å°–å’ŒæŒ‡æ ¹çš„ç›¸å¯¹ä½ç½®
                        let fingersUp = 0;
                        if(h[8].y < h[6].y) fingersUp++;  // é£ŸæŒ‡
                        if(h[12].y < h[10].y) fingersUp++; // ä¸­æŒ‡
                        if(h[16].y < h[14].y) fingersUp++; // æ— åæŒ‡
                        
                        // åªè¦æœ‰ä¸¤æ ¹ä»¥ä¸Šæ‰‹æŒ‡ä¼¸ç›´å°±è®¤ä¸ºæ˜¯å¼ å¼€
                        targetMorph = fingersUp >= 2 ? 1 : 0;
                        info.innerHTML = targetMorph > 0.5 ? "âœ¨ æ˜Ÿäº‘å·²æ‰©æ•£" : "âœ¨ èƒ½é‡å·²æ±‡èš | å¼ å¼€æ‰‹æŒå±•ç¤ºå›å¿†";
                    } else {
                        targetMorph = 0;
                        info.innerText = "ğŸ‘‹ æŒ¥æŒ¥æ‰‹ï¼Œå”¤é†’ 2026 æµé‡‘æ˜Ÿäº‘";
                    }
                });

                const cam = new Camera(document.getElementById('video-input'), {
                    onFrame: async () => { await hands.send({ image: document.getElementById('video-input') }); },
                    // æä½åˆ†è¾¨ç‡é‡‡é›†ï¼Œæå¤§æå‡æ‰‹æœºæ€§èƒ½
                    width: 240, height: 180 
                });
                cam.start();
            } catch(e) { 
                info.innerText = "æ‘„åƒå¤´æœªæˆæƒï¼Œä»…å±•ç¤ºè‡ªåŠ¨åŠ¨ç”»";
                // å¦‚æœæ²¡æœ‰æ‘„åƒå¤´ï¼Œå°±è‡ªåŠ¨æ¼”ç¤ºå¼ åˆ
                setInterval(() => { targetMorph = targetMorph === 0 ? 1 : 0; }, 4000);
            }
        }

        window.onload = () => { init(); startAI(); };
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
