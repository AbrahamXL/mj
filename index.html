<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2026å…ƒæ—¦å¿«ä¹ - æé€Ÿä¼˜åŒ–ç‰ˆ</title>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=ZCOOL+XiaoWei&family=Playfair+Display:ital,wght@1,900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; touch-action: none; }
        #container { position: relative; width: 100vw; height: 100vh; background: #050208; }
        
        #title-container {
            position: absolute; top: 10%; width: 100%; text-align: center; pointer-events: none; z-index: 100;
        }

        #main-title {
            font-weight: normal; margin: 0; padding: 0 10px;
            color: transparent;
            background-image: linear-gradient(135deg, #FFF 0%, #FFD700 40%, #8A2BE2 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            background-clip: text;
            /* ç®€åŒ–é˜´å½±ä»¥æå‡æ¸²æŸ“æ€§èƒ½ */
            filter: drop-shadow(0px 2px 4px rgba(0,0,0,0.5));
            animation: artisticShimmer 5s linear infinite alternate;
        }

        #main-title .year {
            font-family: 'Playfair Display', serif; font-weight: 900;
            font-size: clamp(3.5rem, 15vw, 6rem); display: block; line-height: 1;
        }

        #main-title .bless-1 { 
            font-family: 'Ma Shan Zheng', cursive; 
            font-size: clamp(2.8rem, 12vw, 5rem); 
            display: block; 
            margin-top: 5px;
            line-height: 1.2;
            padding-bottom: 20px;
        }
        
        #main-title .bless-2 { 
            font-family: 'ZCOOL XiaoWei', serif;
            font-size: clamp(1rem, 4.5vw, 1.8rem); display: block; letter-spacing: 0.2em;
        }

        @keyframes artisticShimmer { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }

        #info-instructions {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.6); background: rgba(0,0,0,0.4); 
            padding: 6px 20px; border-radius: 50px; font-size: 0.7rem; z-index: 100; white-space: nowrap;
        }
        #video-input { display: none; }
    </style>
</head>
<body>
    <div id="title-container">
        <h1 id="main-title">
            <span class="year">2026</span>
            <span class="bless-1">å…ƒæ—¦å¿«ä¹</span>
            <span class="bless-2">å¤©å¤©å¼€å¿ƒï¼Œå­¦ä¸šæœ‰æˆ</span>
        </h1>
    </div>

    <div id="container">
        <div id="info-instructions">æ­£åœ¨åŠ è½½...</div>
        <video id="video-input" playsinline></video>
    </div>

    <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);
        
        let scene, camera, renderer, particleSystem, mainGroup, imageGroup;
        let positions, targets, morphFactor = 0, targetMorph = 0;
        let lastHandUpdateTime = 0;

        const COUNT = isMobile ? 1200 : 4000; // å¤§å¹…å‡å°‘ç²’å­

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 500);
            camera.position.z = 85;

            // æé€Ÿæ¨¡å¼ï¼šå…³é—­æŠ—é”¯é½¿ï¼Œè°ƒä½åƒç´ æ¯”
            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(isMobile ? 1 : 1.5);
            document.getElementById('container').appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            // ç²’å­å‡ ä½•ä½“ä¼˜åŒ–
            const geo = new THREE.BufferGeometry();
            positions = new Float32Array(COUNT * 3);
            targets = new Float32Array(COUNT * 3);
            const colors = new Float32Array(COUNT * 3);
            
            const colorA = new THREE.Color(0xffd700); // é‡‘
            const colorB = new THREE.Color(0x8a2be2); // ç´«

            for(let i=0; i<COUNT; i++) {
                // èºæ—‹å¸ƒå±€
                const dist = Math.random() * 25;
                const angle = dist * 0.5 + (i % 3) * (Math.PI * 2 / 3);
                const x = Math.cos(angle) * dist + (Math.random()-0.5)*3;
                const y = (Math.random()-0.5)*4;
                const z = Math.sin(angle) * dist + (Math.random()-0.5)*3;

                positions[i*3] = x; positions[i*3+1] = y; positions[i*3+2] = z;

                // ç›®æ ‡ä½ç½®ï¼ˆçƒä½“æ•£å¼€ï¼‰
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                const r = 50 + Math.random() * 20;
                targets[i*3] = r * Math.sin(theta) * Math.cos(phi);
                targets[i*3+1] = r * Math.sin(theta) * Math.sin(phi);
                targets[i*3+2] = r * Math.cos(theta);

                // é¢œè‰²
                const mixCol = colorA.clone().lerp(colorB, dist/25);
                colors[i*3] = mixCol.r; colors[i*3+1] = mixCol.g; colors[i*3+2] = mixCol.b;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: isMobile ? 1.8 : 1.2, // å¢å¤§ç²’å­æ˜¾å¾—å¯†é›†
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.8,
                depthWrite: false
            });

            particleSystem = new THREE.Points(geo, material);
            mainGroup.add(particleSystem);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // ç¼“åŠ¨åŠ¨ç”»
            morphFactor += (targetMorph - morphFactor) * 0.1;
            mainGroup.rotation.y += 0.005;

            const posArr = particleSystem.geometry.attributes.position.array;
            for(let i=0; i<COUNT * 3; i++) {
                // æç®€æ’å€¼ï¼Œä¸åˆ›å»ºå¯¹è±¡
                posArr[i] = positions[i] * (1 - morphFactor) + targets[i] * morphFactor;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
            
            renderer.render(scene, camera);
        }

        async function startAI() {
            const info = document.getElementById('info-instructions');
            try {
                const hands = new Hands({ locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}` });
                hands.setOptions({ 
                    maxNumHands: 1, 
                    modelComplexity: 0, 
                    minDetectionConfidence: 0.5 
                });

                hands.onResults(res => {
                    // é™é¢‘å¤„ç†ï¼Œå‡å°‘è®¡ç®—
                    const now = Date.now();
                    if(now - lastHandUpdateTime < 40) return; 
                    lastHandUpdateTime = now;

                    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                        const h = res.multiHandLandmarks[0];
                        // ç®€åŒ–é€»è¾‘ï¼šåªçœ‹é£ŸæŒ‡ä½ç½®åˆ¤æ–­å¼€åˆ
                        const isOpen = h[8].y < h[6].y;
                        targetMorph = isOpen ? 1 : 0;
                        info.innerHTML = "âœ¨ å·²è¿æ¥ | å¼ å¼€/æ¡æ‹³";
                    } else {
                        targetMorph = 0;
                        info.innerText = "ğŸ‘‹ æŒ¥æ‰‹å¼€å¯ 2026";
                    }
                });

                const cam = new Camera(document.getElementById('video-input'), {
                    onFrame: async () => { await hands.send({ image: document.getElementById('video-input') }); },
                    width: 240, height: 180 // æè‡´é™ä½ç›¸æœºåˆ†è¾¨ç‡
                });
                cam.start();
            } catch(e) { info.innerText = "è¯·ä½¿ç”¨ç°ä»£æµè§ˆå™¨å¹¶æˆæƒç›¸æœº"; }
        }

        window.onload = () => { init(); startAI(); };
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
