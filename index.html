<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>2026 Private Gallery</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@1,400;1,700&family=Syncopate:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { 
            width: 100%; height: 100%; margin: 0; padding: 0; 
            overflow: hidden; background: #000; position: fixed;
        }
        
        /* 强制画布锁定在屏幕左上角，并填满逻辑尺寸 */
        canvas { 
            position: absolute; top: 0; left: 0;
            width: 100% !important; height: 100% !important;
            display: block; filter: contrast(1.1) saturate(1.2); 
        }
        
        #ui { 
            position: absolute; top: 40%; left: 50%; 
            transform: translate(-50%, -50%); width: 100%; text-align: center; 
            pointer-events: none; z-index: 5; transition: opacity 0.5s ease;
        }
        .year-display {
            font-size: 18vw; font-weight: 700; color: rgba(255, 255, 255, 0.15);
            -webkit-text-stroke: 1px rgba(255, 215, 0, 0.2); margin: 0;
        }
        .sub-title {
            font-family: 'Playfair Display', serif; font-style: italic; font-size: 4.5vw;
            color: rgba(255, 255, 255, 0.4); margin-top: 5px;
        }
        #status {
            position: absolute; bottom: calc(40px + env(safe-area-inset-bottom)); 
            left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.4); font-size: 0.65rem; letter-spacing: 2px; z-index: 10;
        }
        video { display: none; }
    </style>
</head>
<body>
    <div id="ui"><h1 class="year-display">2026</h1><div class="sub-title">Happy New Year</div></div>
    <div id="status">TAP TO START</div>
    <canvas id="c"></canvas>
    <video id="v" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const folderName = "mj"; 
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        let w, h, dpr, photos = [], particles = [], rockets = [];
        let isStarMode = false, isPinching = false, handX = 0.5, handY = 0.5;
        let zoomLerp = 0, currentFocusIndex = 0, galaxyTime = 0;

        // 重新设计的 Resize：采用最保守的缩放方案
        function resize() {
            w = window.innerWidth;
            h = window.innerHeight;
            dpr = window.devicePixelRatio || 1;
            
            // 设置画布物理像素
            canvas.width = Math.floor(w * dpr);
            canvas.height = Math.floor(h * dpr);
            
            // 彻底重置所有变换，重新设置缩放
            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.scale(dpr, dpr); 
        }

        // 优化投影逻辑，确保 (0,0,0) 始终对应屏幕逻辑中心
        function project(x, y, z, rx, ry) {
            let x1 = x * Math.cos(ry) - z * Math.sin(ry);
            let z1 = x * Math.sin(ry) + z * Math.cos(ry);
            let y2 = y * Math.cos(rx) - z1 * Math.sin(rx);
            let z2 = y * Math.sin(rx) + z1 * Math.cos(rx);
            
            // 增加基础景深，防止照片离镜头太近而显得过大
            const fov = Math.max(w, h) * 0.8; 
            const s = fov / (fov + z2 + 800); 
            return { x: x1 * s + w / 2, y: y2 * s + h / 2, s };
        }

        // 简化版粒子系统
        class Particle {
            constructor(x, y, z, hue) {
                this.x = x; this.y = y; this.z = z; this.hue = hue;
                this.angle = Math.random() * Math.PI * 2;
                this.radius = 150 + Math.random() * 400;
                this.alpha = 1; 
                this.vx = (Math.random()-0.5)*12; this.vy = (Math.random()-0.5)*12; this.vz = (Math.random()-0.5)*12;
            }
            update() {
                if (isStarMode) {
                    this.angle += 0.005;
                    this.x += (Math.cos(this.angle) * this.radius - this.x) * 0.05;
                    this.z += (Math.sin(this.angle) * this.radius - this.z) * 0.05;
                    this.alpha = 0.5;
                } else {
                    this.vx *= 0.96; this.vy *= 0.96; this.vy += 0.12;
                    this.x += this.vx; this.y += this.vy; this.z += this.vz;
                    this.alpha -= 0.015;
                }
            }
            draw(rx, ry) {
                if (this.alpha <= 0) return;
                const p = project(this.x, this.y, this.z, rx, ry);
                ctx.fillStyle = `hsla(${this.hue}, 80%, 70%, ${this.alpha})`;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.s * 1.5, 0, Math.PI * 2); ctx.fill();
            }
        }

        class Rocket {
            constructor() {
                this.x = (Math.random()-0.5)*300; this.y = h/2 + 200; this.z = (Math.random()-0.5)*200;
                this.targetY = -100 - Math.random()*200; this.hue = Math.random()*60;
            }
            update() { this.y -= 15; if (this.y <= this.targetY) { this.explode(); return true; } }
            draw(rx, ry) {
                const p = project(this.x, this.y, this.z, rx, ry);
                ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI * 2); ctx.fill();
            }
            explode() { for(let i=0; i<60; i++) particles.push(new Particle(this.x, this.y, this.z, this.hue)); }
        }

        function animate() {
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = `rgba(0,0,10,${0.25 + zoomLerp*0.25})`;
            ctx.fillRect(0, 0, w, h);
            
            const rx = (handY - 0.5) * 0.4 * (1-zoomLerp);
            const ry = (handX - 0.5) * 0.4 * (1-zoomLerp);

            ctx.globalCompositeOperation = 'lighter';
            if (!isStarMode && Math.random() < 0.04) rockets.push(new Rocket());
            rockets = rockets.filter(r => { r.draw(rx, ry); return !r.update(); });
            particles = particles.filter(p => { p.update(); p.draw(rx, ry); return p.alpha > 0; });

            if (isStarMode && photos.length > 0) {
                ctx.globalCompositeOperation = 'source-over';
                zoomLerp += ((isPinching ? 1 : 0) - zoomLerp) * 0.12;
                let targetIdx = handX * (photos.length - 1);
                currentFocusIndex += (targetIdx - currentFocusIndex) * 0.12;

                // 按 Z 轴排序绘图，解决层级问题
                const sortedPhotos = [...photos].sort((a, b) => {
                    const az = a.z * (1 - Math.max(0, 1 - Math.abs(photos.indexOf(a) - currentFocusIndex) * 0.6) * 0.5);
                    const bz = b.z * (1 - Math.max(0, 1 - Math.abs(photos.indexOf(b) - currentFocusIndex) * 0.6) * 0.5);
                    return bz - az;
                });

                sortedPhotos.forEach((pData) => {
                    const i = photos.indexOf(pData);
                    let diff = Math.abs(i - currentFocusIndex);
                    let focus = Math.max(0, 1 - diff * 0.7);
                    let active = Math.abs(i - Math.round(currentFocusIndex)) < 0.5;
                    
                    ctx.globalAlpha = (0.15 + focus * 0.85) * (1-zoomLerp) + (active ? zoomLerp : 0);
                    
                    // 核心修改：大幅减小放大后的偏移和距离
                    let zPush = active ? zoomLerp * 350 : 0;
                    let p = project(pData.x * (1-focus*0.6), 0, pData.z * (1-focus*0.6) + 250 + zPush, rx, ry);
                    
                    // 核心修改：减小基础倍率 (0.2) 和 放大倍率 (0.5)
                    let baseScale = w < 600 ? 0.22 : 0.35;
                    let imgScale = p.s * (0.5 + focus * 0.5 + (active ? zoomLerp * 0.5 : 0)) * baseScale;
                    
                    let sw = pData.img.width * imgScale;
                    let sh = pData.img.height * imgScale;
                    ctx.drawImage(pData.img, p.x - sw/2, p.y - sh/2, sw, sh);
                });
            }
            ctx.globalAlpha = 1;
            requestAnimationFrame(animate);
        }

        async function setup() {
            const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5});
            hands.onResults(res => {
                if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                    const lm = res.multiHandLandmarks[0];
                    handX = 1 - lm[9].x; handY = lm[9].y;
                    const palm = Math.hypot(lm[0].x - lm[9].x, lm[0].y - lm[9].y);
                    isStarMode = Math.hypot(lm[12].x-lm[0].x, lm[12].y-lm[0].y) > palm * 1.5;
                    isPinching = isStarMode && Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < palm * 0.4;
                    document.getElementById('status').innerText = isStarMode ? (isPinching ? "VIEWING" : "GALLERY") : "FIREWORKS";
                }
            });
            const video = document.getElementById('v');
            const cam = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 480, height: 640
            });
            window.addEventListener('touchstart', () => { 
                document.getElementById('status').innerText = "STARTING...";
                cam.start(); 
            }, {once: true});
        }

        // 初始化环境
        resize();
        window.addEventListener('resize', resize);
        
        // 预加载所有照片
        let loadedCount = 0;
        for(let i=1; i<=13; i++) {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.src = `${folderName}/${i}.jpg`;
            img.onload = () => {
                const ang = -Math.PI/2 + (i-1) * (Math.PI * 0.15); // 扇形排列而非圆圈
                photos.push({img, x: Math.sin(ang)*600, z: Math.cos(ang)*300});
                if (++loadedCount === 13) { setup(); animate(); }
            };
        }
    </script>
</body>
</html>
