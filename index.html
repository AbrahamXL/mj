<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>2026å…ƒæ—¦å¿«ä¹ - å…¨å½©èƒ½é‡çƒ</title>
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+XiaoWei&family=Playfair+Display:ital,wght@1,900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Montserrat', sans-serif; }
        /* èƒŒæ™¯è°ƒæ•´ä¸ºæ›´æ·±é‚ƒçš„å®‡å®™æ„Ÿ */
        #container { position: relative; width: 100vw; height: 100vh; background: radial-gradient(circle at center, #0d0d1a 0%, #000 100%); }
        
        #title-container {
            position: absolute; top: 10%; width: 100%; text-align: center; pointer-events: none; z-index: 10;
        }

        /* é…åˆæ–°çš„å¤šå½©å…‰çƒï¼Œæ–‡å­—çš„æ¸å˜ä¹Ÿå˜å¾—æ›´ä¸°å¯Œã€å¸¦æœ‰å…¨æ¯æ„Ÿ */
        #main-title {
            font-family: 'ZCOOL XiaoWei', serif;
            font-weight: normal; margin: 0; padding: 0 20px; line-height: 1.2;
            color: transparent;
            background-image: linear-gradient(
                135deg,
                #FFFFFF 0%,    /* çº¯ç™½ */
                #FFD700 25%,   /* é»„é‡‘ */
                #FF69B4 50%,   /* çƒ­ç²‰ */
                #00FFFF 75%,   /* é’å…‰ */
                #9370DB 100%   /* ç´«ç½—å…° */
            );
            background-size: 300% auto; /* æ‹‰å¤§èƒŒæ™¯è®©æ¸å˜æ›´å¹³æ»‘ */
            -webkit-background-clip: text;
            background-clip: text;
            text-shadow: 
                0px 0px 10px rgba(255,255,255,0.5),
                0px 0px 30px rgba(255, 100, 255, 0.3); /* å¢åŠ ä¸€ç‚¹ç´«ç²‰è‰²å…‰æ™• */
            animation: artisticShimmer 5s linear infinite alternate;
        }

        #main-title .year {
            font-family: 'Playfair Display', serif; font-style: italic; font-weight: 900;
            font-size: 7rem; display: block; filter: brightness(1.3);
        }

        #main-title .bless-1 { font-size: 4rem; display: block; letter-spacing: 0.2em; margin-top: -10px; }
        #main-title .bless-2 { font-size: 2.5rem; display: block; letter-spacing: 0.5em; opacity: 0.9; margin-top: 10px; }

        @keyframes artisticShimmer {
            0% { background-position: 0% 50%; filter: brightness(1); }
            100% { background-position: 100% 50%; filter: brightness(1.2); }
        }

        #info-instructions {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.8); background: rgba(255,255,255,0.05); 
            padding: 12px 35px; border-radius: 50px; border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(15px); font-size: 0.8rem; z-index: 100; letter-spacing: 2px; box-shadow: 0 0 20px rgba(255,255,255,0.1);
        }
        
        #video-input { display: none; }
    </style>
</head>
<body>
    <div id="title-container">
        <h1 id="main-title">
            <span class="year">2026</span>
            <span class="bless-1">å…ƒæ—¦å¿«ä¹</span>
            <span class="bless-2">å­¦ä¸šæœ‰æˆ</span>
        </h1>
    </div>

    <div id="container">
        <div id="info-instructions">æ­£åœ¨æ±‡èšå…¨å½©èƒ½é‡...</div>
        <video id="video-input" playsinline></video>
    </div>

    <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particleSystem, mainGroup, imageGroup;
        let treePos = [], starPos = [], currentPos = [];
        let morphFactor = 0, targetMorph = 0, targetRotX = 0, targetRotY = 0;

        const COUNT = 7000; // å†æ¬¡å¢åŠ ç²’å­æ•°ï¼Œè®©è‰²å½©è¿‡æ¸¡æ›´ç»†è…»
        const IMG_COUNT = 10;

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            // ä½¿ç”¨æ›´çº¯å‡€çš„ç™½å…‰æ ¸å¿ƒï¼Œè®©å åŠ è‰²æ›´é²œè‰³
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.1, 'rgba(255,255,255,0.8)');
            grad.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 65;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            // ç…§ç‰‡ç¯
            imageGroup = new THREE.Group();
            mainGroup.add(imageGroup);
            const loader = new THREE.TextureLoader();
            for(let i=1; i<=IMG_COUNT; i++) {
                const texture = loader.load(`./mj/${i}.jpg`, undefined, undefined, () => {});
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(8, 10), material);
                const angle = ((i-1) / IMG_COUNT) * Math.PI * 2;
                mesh.position.set(Math.cos(angle) * 28, -6, Math.sin(angle) * 28); // ç¨å¾®å†ä¸‹ç§»ä¸€ç‚¹
                mesh.lookAt(0, -6, 0); 
                imageGroup.add(mesh);
            }

            // --- å…¨æ–°è®¾è®¡çš„ï¼šå…¨å…‰è°±èƒ½é‡å…‰çƒ ---
            const geo = new THREE.BufferGeometry();
            const posArr = new Float32Array(COUNT * 3);
            const colArr = new Float32Array(COUNT * 3);
            
            // å®šä¹‰ä¸°å¯Œçš„è‰²å½©ç›˜
            const palette = {
                white: new THREE.Color(0xFFFFFF),
                gold: new THREE.Color(0xFFD700),
                orange: new THREE.Color(0xFF4500), // çƒ­æ©™
                pink: new THREE.Color(0xFF1493),   // æ·±ç²‰
                purple: new THREE.Color(0x9400D3), // ç´«ç½—å…°
                blue: new THREE.Color(0x00BFFF),   // æ·±å¤©è“
                cyan: new THREE.Color(0x00FFFF),   // é’è‰²
                green: new THREE.Color(0x00FF7F)   // æ˜¥ç»¿
            };

            const coreLimit = 2800;
            const orbitLimit = 5800;

            for(let i=0; i<COUNT; i++) {
                let v = new THREE.Vector3();
                let c = new THREE.Color();
                
                if (i < coreLimit) { 
                    // === 1. ç‚½çƒ­å…‰è°±æ ¸å¿ƒ (Hot Spectrum Core) ===
                    const radius = 7.5 * Math.cbrt(Math.random());
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    v.setFromSphericalCoords(radius, phi, theta);
                    
                    // ä¸­å¿ƒç™½ -> ä¸­é—´é‡‘ -> è¾¹ç¼˜æ©™çº¢/ç«ç²‰
                    const t = radius / 7.5;
                    if (t < 0.3) c.copy(palette.white);
                    else if (t < 0.7) c.lerpColors(palette.gold, palette.orange, (t-0.3)/0.4);
                    else c.lerpColors(palette.orange, palette.pink, (t-0.7)/0.3);
                } 
                else if (i < orbitLimit) {
                    // === 2. éœ“è™¹æ¸å˜è½¨é“ (Neon Gradient Orbits) ===
                    const orbitIdx = (i - coreLimit) % 3;
                    const angle = (i / coreLimit) * Math.PI * 2 * (6 + orbitIdx);
                    const baseRadius = 12.5 + orbitIdx * 2.5;
                    
                    v.set(baseRadius * Math.cos(angle), 0, baseRadius * Math.sin(angle));
                    const tiltAxis = new THREE.Vector3(Math.cos(orbitIdx*1.5), Math.sin(orbitIdx), Math.cos(orbitIdx)).normalize();
                    v.applyAxisAngle(tiltAxis, Math.PI / (2.5 + orbitIdx*0.5));
                    v.addScaledVector(new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5), 1.2);

                    // æ²¿è½¨é“è¿›è¡Œè‰²å½©æ¸å˜ (ä½¿ç”¨ sin(angle) å®ç°å¹³æ»‘å¾ªç¯)
                    const gradientPos = (Math.sin(angle * 1.5) + 1) / 2; 
                    if (orbitIdx === 0) c.lerpColors(palette.cyan, palette.purple, gradientPos); // é’ç´«è½¨é“
                    else if (orbitIdx === 1) c.lerpColors(palette.pink, palette.gold, gradientPos); // ç²‰é‡‘è½¨é“
                    else c.lerpColors(palette.blue, palette.green, gradientPos); // è“ç»¿è½¨é“
                }
                else {
                    // === 3. å¤šå½©æ˜Ÿå°˜å…‰æ™• (Colorful Stardust Aura) ===
                    const radius = 19 + Math.random() * 12;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    v.setFromSphericalCoords(radius, phi, theta);
                    
                    // éšæœºä»è‰²ç›˜ä¸­é€‰å–ä¸€ç§é¢œè‰²
                    const colorKeys = Object.keys(palette);
                    const randomKey = colorKeys[Math.floor(Math.random() * colorKeys.length)];
                    c.copy(palette[randomKey]).multiplyScalar(0.5); // ç¨å¾®æš—ä¸€ç‚¹
                }

                treePos.push(v.clone());
                starPos.push(new THREE.Vector3().setFromSphericalCoords(55 + Math.random()*45, Math.random()*Math.PI, Math.random()*Math.PI*2));
                currentPos.push(v.clone());
                
                posArr[i*3] = v.x; posArr[i*3+1] = v.y; posArr[i*3+2] = v.z;
                colArr[i*3] = c.r; colArr[i*3+1] = c.g; colArr[i*3+2] = c.b;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colArr, 3));

            // ä½¿ç”¨ AdditiveBlending æ··åˆæ¨¡å¼ï¼Œè®©å¤šå½©ç²’å­å åŠ åæ›´äº®ã€æ›´è¿·å¹»
            particleSystem = new THREE.Points(geo, new THREE.PointsMaterial({ 
                size: 0.75, map: createStarTexture(), transparent: true, blending: THREE.AdditiveBlending, 
                vertexColors: true, depthWrite: false, sizeAttenuation: true 
            }));
            mainGroup.add(particleSystem);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = Date.now();
            morphFactor = THREE.MathUtils.lerp(morphFactor, targetMorph, 0.2);
            
            // è‡ªè½¬ä¸äº¤äº’æ—‹è½¬
            mainGroup.rotation.y += 0.0025;
            mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, targetRotY + mainGroup.rotation.y * 0.5, 0.1);
            mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, targetRotX, 0.1);

            imageGroup.children.forEach((mesh) => {
                mesh.material.opacity = THREE.MathUtils.lerp(0, 0.8, (morphFactor - 0.2) * 5);
                mesh.scale.setScalar(THREE.MathUtils.clamp(morphFactor * 1.1, 0.01, 1.1));
            });

            const posAttr = particleSystem.geometry.attributes.position;
            for(let i=0; i<COUNT; i++) {
                currentPos[i].lerpVectors(treePos[i], starPos[i], morphFactor);
                
                // åŠ¨æ€å‘¼å¸æ•ˆæœ
                let pulse = 0;
                // æ ¸å¿ƒå’Œè½¨é“æœ‰ä¸åŒçš„å¾‹åŠ¨é¢‘ç‡
                if (i < 2800) pulse = Math.sin(now * 0.002) * 0.03 * currentPos[i].length(); 
                else pulse = Math.sin(now * 0.003 + i) * 0.08; 

                posAttr.array[i*3] = currentPos[i].x * (1 + pulse*0.1);
                posAttr.array[i*3+1] = currentPos[i].y * (1 + pulse*0.1);
                posAttr.array[i*3+2] = currentPos[i].z * (1 + pulse*0.1);
            }
            posAttr.needsUpdate = true;
            renderer.render(scene, camera);
        }

        async function startAI() {
            const info = document.getElementById('info-instructions');
            try {
                const hands = new Hands({ locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}` });
                hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
                
                hands.onResults(res => {
                    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                        const h = res.multiHandLandmarks[0];
                        const fingers = [8, 12, 16, 20];
                        let openCount = 0;
                        fingers.forEach(tip => { if (h[tip].y < h[tip-2].y) openCount++; });
                        targetMorph = openCount / 4;
                        targetRotY = (0.5 - h[9].x) * 4;
                        targetRotX = (h[9].y - 0.5) * 2;
                        info.innerHTML = "âœ¨ å…¨å½©æ˜Ÿæ²³å·²å¼€å¯ | ç§»åŠ¨æ‰‹æŒæ§åˆ¶è§†è§’";
                    } else {
                        info.innerText = "ğŸ‘‹ æŒ¥æŒ¥æ‰‹ï¼Œé‡Šæ”¾æ–°å¹´è‰²å½©";
                    }
                });

                const cam = new Camera(document.getElementById('video-input'), {
                    onFrame: async () => { await hands.send({ image: document.getElementById('video-input') }); },
                    width: 640, height: 480
                });
                cam.start();
            } catch(e) {
                info.innerText = "âš ï¸ æ‘„åƒå¤´å·²é™é»˜è¿è¡Œ";
            }
        }

        window.onload = () => { init(); startAI(); };
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
