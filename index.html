<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>2026 Artistic Cake</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&family=Playfair+Display:ital,wght@1,400&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; }
        html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background: #020205; position: fixed; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }
        #ui { 
            position: absolute; top: 40px; left: 0; width: 100%; z-index: 10; 
            pointer-events: none; transition: opacity 0.8s ease; text-align: center;
        }
        .year { 
            font-family: 'Cinzel Decorative', cursive;
            font-size: 15vw; color: rgba(255,230,150,0.4); 
            margin: 0; line-height: 0.8; text-shadow: 0 0 30px rgba(255,200,50,0.3);
        }
        .subtitle {
            font-family: 'Playfair Display', serif; font-style: italic;
            font-size: 5vw; color: rgba(255, 255, 255, 0.6); margin-top: 10px; letter-spacing: 2px;
        }
        #status { 
            margin-top: 20px; color: rgba(255,255,255,0.8); font-size: 12px; 
            padding: 6px 12px; background: rgba(50,50,50,0.3); 
            display: inline-block; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1);
            font-family: sans-serif;
        }
        video { display: none; }
        /* æ±‡èšæ—¶UIæ·±åº¦æ·¡å‡º */
        body.gathering #ui { opacity: 0; transform: translateY(-20px); }
    </style>
</head>
<body>
    <div id="ui">
        <h1 class="year">2026</h1>
        <div class="subtitle">æµå…‰æ˜Ÿè¾° Â· ä¸ºä½ æ±‡èš</div>
        <div id="status">ç³»ç»Ÿå¯åŠ¨ä¸­...</div>
    </div>
    <canvas id="c"></canvas>
    <video id="v" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const totalPhotos = 10;
        let w, h, dpr;
        let photos = [], bgStars = [], explosions = [], cakeParticles = [];
        let isHandVisible = false, isPinching = false;
        let gatherLerp = 0, time = 0;

        function resize() {
            w = window.innerWidth; h = window.innerHeight;
            // é™åˆ¶ DPR ä»¥ä¿è¯åœ¨å¤§é‡ç²’å­ä¸‹çš„æ€§èƒ½
            dpr = Math.min(window.devicePixelRatio || 1, 2);
            canvas.width = w * dpr; canvas.height = h * dpr;
            ctx.scale(dpr, dpr);
            initParticles();
        }

        // --- æ ¸å¿ƒï¼šè‰ºæœ¯è›‹ç³•ç»“æ„ç”Ÿæˆ ---
        function getCylinderPoint(radius, heightBot, heightTop) {
            let a = Math.random() * Math.PI * 2;
            let h = heightBot + Math.random() * (heightTop - heightBot);
            // å¢åŠ ä¸€ç‚¹éšæœºæ‰°åŠ¨ï¼Œè®©è¡¨é¢çœ‹èµ·æ¥æ›´æœ‰ç³–éœœè´¨æ„Ÿ
            let r = radius + (Math.random() - 0.5) * 5;
            return { x: Math.cos(a) * r, y: h, z: Math.sin(a) * r };
        }

        function initParticles() {
            bgStars = []; cakeParticles = [];
            // èƒŒæ™¯æ˜Ÿè¾°
            for(let i=0; i<150; i++) {
                bgStars.push({x:(Math.random()-0.5)*w*3, y:(Math.random()-0.5)*h*3, z:Math.random()*1500, size:Math.random()*2.5, hue:200+Math.random()*60});
            }

            // --- ç”Ÿæˆé«˜å¯†åº¦è‰ºæœ¯è›‹ç³• (è¿‘4000ä¸ªç²’å­) ---
            const addParticle = (target, type) => {
                let hue, saturation, lightness, sizeBase;
                // æ ¹æ®ç±»å‹å®šä¹‰è‰ºæœ¯é…è‰²
                if (type === 'base') { // è›‹ç³•ä¸»ä½“ï¼šé¦™æ§Ÿ/å¥¶æ²¹è‰²
                    hue = 35 + Math.random() * 15; saturation = '80%'; lightness = '70%'; sizeBase = 1.5;
                } else if (type === 'rim') { // è¾¹ç¼˜è£…é¥°ï¼šäº®é‡‘è‰²
                    hue = 45 + Math.random() * 5; saturation = '100%'; lightness = '85%'; sizeBase = 2.5;
                } else if (type === 'gem') { // ç‚¹ç¼€å®çŸ³ï¼šçº¢å®çŸ³è‰²/äº®ç™½
                    hue = Math.random() < 0.7 ? 0 : 200; saturation = '90%'; lightness = '60%'; sizeBase = 3.5;
                }

                cakeParticles.push({
                    scatterX: (Math.random()-0.5)*w*2, scatterY: (Math.random()-0.5)*h*2, scatterZ: Math.random()*1000,
                    targetX: target.x, targetY: target.y, targetZ: target.z,
                    color: `hsla(${hue}, ${saturation}, ${lightness}, `, // é¢„å­˜é¢œè‰²å­—ç¬¦ä¸²å‰ç¼€
                    size: sizeBase + Math.random() * 1.5,
                    speedOffset: Math.random() * Math.PI * 2,
                    type: type
                });
            };

            // 1. åº•å±‚ (å®½è€Œåš) - 1500ä¸ª
            for(let i=0; i<1500; i++) addParticle(getCylinderPoint(200, 100, 220), 'base');
            // åº•å±‚è¾¹ç¼˜è£…é¥°ç¯
            for(let i=0; i<300; i++) {
                let a = (i/300)*Math.PI*2;
                addParticle({x:Math.cos(a)*205, y:100, z:Math.sin(a)*205}, 'rim');
                if(i%10===0) addParticle({x:Math.cos(a)*205, y:100, z:Math.sin(a)*205}, 'gem');
            }

            // 2. ä¸­å±‚ (é€‚ä¸­) - 1000ä¸ª
            for(let i=0; i<1000; i++) addParticle(getCylinderPoint(130, -20, 100), 'base');
            // ä¸­å±‚è¾¹ç¼˜è£…é¥°ç¯
            for(let i=0; i<250; i++) {
                let a = (i/250)*Math.PI*2;
                addParticle({x:Math.cos(a)*135, y:-20, z:Math.sin(a)*135}, 'rim');
            }

            // 3. é¡¶å±‚ (çª„) - 600ä¸ª
            for(let i=0; i<600; i++) addParticle(getCylinderPoint(70, -100, -20), 'base');
            
            // 4. é¡¶éƒ¨è£…é¥°çƒ/èœ¡çƒ›å…‰ - 150ä¸ª
            for(let i=0; i<150; i++) {
                 let a = Math.random()*Math.PI*2, r = Math.random()*30;
                 addParticle({x:Math.cos(a)*r, y:-120 - Math.random()*40, z:Math.sin(a)*r}, 'rim');
            }
        }

        function project(x, y, z) {
            const fov = 700; const s = fov / (fov + z);
            return { x: x * s + w/2, y: y * s + h/2, scale: s };
        }

        class Explosion {
            constructor(x, y) {
                this.p = [];
                for(let i=0; i<50; i++) {
                    let a=Math.random()*Math.PI*2, spd=Math.random()*8;
                    // çƒŸèŠ±ä¹Ÿæ˜¯é‡‘è‰²ç³»
                    this.p.push({x, y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, alpha:1, hue: 40+Math.random()*20});
                }
            }
            update() { this.p.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.vy+=0.15;p.alpha-=0.025;}); this.p=this.p.filter(p=>p.alpha>0); }
            draw() { this.p.forEach(p=>{ctx.fillStyle=`hsla(${p.hue},100%,70%,${p.alpha})`;ctx.beginPath();ctx.arc(p.x,p.y,2.5,0,Math.PI*2);ctx.fill();}); }
        }

        function animate() {
            time += 0.02;
            ctx.globalCompositeOperation = 'source-over';
            // ä½¿ç”¨éå¸¸æ·±çš„å¸¦ä¸€ç‚¹ç‚¹è“ç´«è‰²çš„èƒŒæ™¯ï¼Œæå‡é«˜çº§æ„Ÿ
            ctx.fillStyle = 'rgba(8, 5, 16, 0.3)'; 
            ctx.fillRect(0, 0, w, h);

            let targetGather = isPinching ? 1 : 0;
            gatherLerp += (targetGather - gatherLerp) * 0.08; // ç¨å¾®è°ƒæ…¢ä¸€ç‚¹æ±‡èšé€Ÿåº¦ï¼Œæ›´æœ‰ä»ªå¼æ„Ÿ
            if(gatherLerp > 0.1) document.body.classList.add('gathering');
            else document.body.classList.remove('gathering');

            let rot = time * 0.6;
            let tilt = Math.sin(time*0.4) * 0.1; // è½»å¾®çš„å€¾æ–œæ‘†åŠ¨

            // --- å¼€å¯å‘å…‰æ¸²æŸ“æ¨¡å¼ ---
            ctx.globalCompositeOperation = 'lighter'; 

            // 1. èƒŒæ™¯æ˜Ÿè¾°
            bgStars.forEach(s => {
                s.z-=2; if(s.z<0) s.z=1500;
                let p=project(s.x, s.y, s.z);
                ctx.fillStyle=`hsla(${s.hue},60%,40%,${0.5*(1-s.z/1500)})`;
                ctx.beginPath();ctx.arc(p.x,p.y,s.size*p.scale,0,Math.PI*2);ctx.fill();
            });

            // 2. æ ¸å¿ƒï¼šç»˜åˆ¶è‰ºæœ¯ç²’å­è›‹ç³•
            // æ ¹æ® Z è½´æ’åºï¼Œä¿è¯é®æŒ¡å…³ç³»æ­£ç¡®ï¼Œå¢åŠ å®ä½“æ„Ÿ
            cakeParticles.sort((a, b) => b.curZ - a.curZ);

            cakeParticles.forEach(cp => {
                // è®¡ç®—æ—‹è½¬åçš„ç›®æ ‡ä½ç½®
                let tx = cp.targetX*Math.cos(rot) - cp.targetZ*Math.sin(rot);
                let tz = cp.targetX*Math.sin(rot) + cp.targetZ*Math.cos(rot);
                // åŠ ä¸Šè½»å¾®çš„å€¾æ–œ
                let ty = cp.targetY + tz * tilt; 
                tx = tx * Math.cos(tilt);

                // æ’å€¼
                let x = cp.scatterX + (tx - cp.scatterX) * gatherLerp;
                let y = cp.scatterY + (ty - cp.scatterY) * gatherLerp;
                let z = cp.scatterZ + (tz - cp.scatterZ) * gatherLerp;
                cp.curZ = z; // ä¿å­˜ç”¨äºæ’åº

                let p = project(x, y, z);
                
                // æ±‡èšæ—¶ alpha æ›´é«˜ï¼Œä¸”æœ‰å‘¼å¸é—ªçƒæ„Ÿ
                let baseAlpha = 0.2 + gatherLerp * 0.8;
                let flicker = 0.8 + Math.sin(time*3 + cp.speedOffset)*0.2;
                let alpha = baseAlpha * flicker;
                
                // è¾¹ç¼˜è£…é¥°ç²’å­æ›´äº®
                if (cp.type === 'rim' || cp.type === 'gem') alpha = Math.min(1, alpha * 1.5);

                // ç»˜åˆ¶ç²’å­ï¼šä½¿ç”¨é¢„å­˜çš„é¢œè‰²å‰ç¼€ + åŠ¨æ€ alpha
                ctx.fillStyle = cp.color + alpha + ')';
                ctx.beginPath();
                // æ±‡èšæ—¶ç²’å­ç¨å¾®å˜å¤§ä¸€ç‚¹ï¼Œå¢åŠ ç´§å®æ„Ÿ
                let size = cp.size * p.scale * (0.8 + gatherLerp*0.4);
                ctx.arc(p.x, p.y, size, 0, Math.PI*2);
                ctx.fill();
            });

            // 3. çƒŸèŠ±
            if (!isPinching && gatherLerp > 0.2 && Math.random() < 0.08) {
                explosions.push(new Explosion(w/2 + (Math.random()-0.5)*300, h/2 + (Math.random()-0.5)*300));
            }
            explosions.forEach(e => { e.update(); e.draw(); });
            explosions = explosions.filter(e => e.p.length > 0);

            // 4. ç…§ç‰‡æ˜¾ç° (åªåœ¨æ•£å¼€æ—¶)
            ctx.globalCompositeOperation = 'source-over'; // ç…§ç‰‡ä¸éœ€è¦å‘å…‰å åŠ 
            if (photos.length > 0) {
                let visibility = Math.pow(Math.max(0, 1 - gatherLerp * 1.5), 3); // ä½¿ç”¨ç«‹æ–¹æ›²çº¿ï¼Œè®©æ¶ˆå¤±æ›´è¿…é€Ÿ
                if (visibility > 0.01) {
                    photos.forEach((pData, i) => {
                        let sx = pData.seedX + Math.sin(time+i)*40;
                        let sy = pData.seedY + Math.cos(time+i)*40;
                        let sz = pData.seedZ;
                        let p = project(sx, sy, sz);
                        
                        ctx.save();
                        ctx.globalAlpha = visibility * 0.8; // ç…§ç‰‡ç¨å¾®é€æ˜ä¸€ç‚¹ï¼Œèå…¥ç¯å¢ƒ
                        ctx.translate(p.x, p.y);
                        let s = p.scale * 0.28;
                        ctx.drawImage(pData.img, -pData.img.width*s/2, -pData.img.height*s/2, pData.img.width*s, pData.img.height*s);
                        // ç»™ç…§ç‰‡åŠ ä¸€ä¸ªç²¾è‡´çš„é‡‘è¾¹
                        ctx.strokeStyle = `rgba(255,215,0,${visibility})`; ctx.lineWidth = 1;
                        ctx.strokeRect(-pData.img.width*s/2, -pData.img.height*s/2, pData.img.width*s, pData.img.height*s);
                        ctx.restore();
                    });
                }
            }
            requestAnimationFrame(animate);
        }

        async function initAI() {
            document.getElementById('status').innerText = "âœ¨ æ­£åœ¨å”¤é†’æ˜Ÿè¾°...";
            const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5});
            hands.onResults(res => {
                if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                    isHandVisible = true;
                    const lm = res.multiHandLandmarks[0];
                    isPinching = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y) < 0.06;
                    document.getElementById('status').innerText = isPinching ? "ğŸ‚ æ­¤åˆ»ï¼Œä¸ºä½ é—ªè€€" : "ğŸ‘‹ æåˆæ‰‹æŒ‡ï¼Œæ±‡èšç¥ç¦";
                } else {
                    isHandVisible = false; isPinching = false;
                    document.getElementById('status').innerText = "ğŸ‘€ å¯»æ‰¾æ‰‹åŠ¿æŒ‡ä»¤...";
                }
            });

            const cam = new Camera(document.getElementById('v'), {
                onFrame: async () => { await hands.send({image: document.getElementById('v')}); },
                width: 320, height: 240
            });

            cam.start().catch(e => {
                document.getElementById('status').innerText = "âš ï¸ ç‚¹å‡»å±å¹•å¼€å¯ä½“éªŒ";
                window.addEventListener('click', ()=>cam.start(), {once:true});
            });
        }

        resize();
        window.addEventListener('resize', resize);
        let loaded = 0;
        for(let i=1; i<=totalPhotos; i++) {
            const img = new Image(); img.crossOrigin = "anonymous"; img.src = `mj/${i}.jpg`;
            img.onload = () => {
                photos.push({img, seedX:(Math.random()-0.5)*w*1.8, seedY:(Math.random()-0.5)*h*1.8, seedZ:Math.random()*600});
                if(++loaded === totalPhotos) { initAI(); animate(); }
            };
        }
    </script>
</body>
</html>
