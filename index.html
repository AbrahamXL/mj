<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>2026 Fast Gallery</title>
    <style>
        * { box-sizing: border-box; }
        html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background: #000; position: fixed; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }
        #ui { position: absolute; top: 30px; left: 20px; z-index: 10; pointer-events: none; font-family: sans-serif; }
        .year { font-size: 14vw; font-weight: 900; color: rgba(255,215,0,0.3); margin: 0; line-height: 1; }
        #status { margin-top: 10px; color: #fff; font-size: 11px; padding: 4px 8px; background: rgba(255,255,255,0.1); display: inline-block; }
        video { display: none; }
    </style>
</head>
<body>
    <div id="ui"><h1 class="year">2026</h1><div id="status">TAP TO START</div></div>
    <canvas id="c"></canvas>
    <video id="v" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        let w, h, dpr, photos = [];
        let handX = 0, isHandVisible = false, isPinching = false;
        let zoomLerp = 0, currentIdx = 0; 

        function resize() {
            w = window.innerWidth; h = window.innerHeight;
            dpr = Math.min(window.devicePixelRatio || 1, 2); // 限制分辨率最高为2，提升渲染效率
            canvas.width = w * dpr; canvas.height = h * dpr;
            ctx.scale(dpr, dpr);
        }

        function animate() {
            // 背景涂黑，不使用透明度刷新以提升性能
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            if (photos.length > 0) {
                // 1. 大幅提升切换速度系数 (0.1 -> 0.35)
                let targetIdx = isHandVisible ? handX * (photos.length - 1) : currentIdx;
                currentIdx += (targetIdx - currentIdx) * 0.35; 
                
                // 2. 提升缩放响应速度 (0.1 -> 0.4)
                let targetZoom = isPinching ? 1 : 0;
                zoomLerp += (targetZoom - zoomLerp) * 0.4;

                photos.forEach((pData, i) => {
                    let diff = Math.abs(i - currentIdx);
                    // 缩小感应范围，让切换更“清爽”
                    let focus = Math.max(0, 1 - diff * 1.2); 
                    
                    ctx.save();
                    // 基础堆叠位置
                    let bx = 30 + i * 12;
                    let by = 160 + i * 8;
                    
                    // 跟随偏移
                    if (focus > 0) {
                        bx += focus * 40;
                        by += focus * 15;
                    }

                    ctx.translate(bx, by);
                    
                    // 缩放计算
                    let baseScale = (w < 600 ? 0.22 : 0.4);
                    let s = baseScale + (focus * 0.3) + (focus * zoomLerp * 0.6);
                    
                    ctx.globalAlpha = isHandVisible ? (0.2 + focus * 0.8) : 0.3;
                    
                    // 绘制（去掉了所有阴影特效以保证帧率）
                    let iw = pData.img.width * s;
                    let ih = pData.img.height * s;
                    ctx.drawImage(pData.img, 0, 0, iw, ih);

                    // 选中状态的极简边框
                    if (focus > 0.8) {
                        ctx.strokeStyle = '#ffd700';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(0, 0, iw, ih);
                    }
                    ctx.restore();
                });
            }
            requestAnimationFrame(animate);
        }

        async function init() {
            const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0, // 最快速度
                minDetectionConfidence: 0.4,
                minTrackingConfidence: 0.4
            });
            
            hands.onResults(res => {
                if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                    isHandVisible = true;
                    const lm = res.multiHandLandmarks[0];
                    // 左右镜像调整
                    handX = 1 - lm[9].x; 
                    
                    // 灵敏的捏合判定
                    const pinch = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                    isPinching = pinch < 0.06;
                    
                    document.getElementById('status').innerText = isPinching ? "ZOOM ACTIVE" : "HAND DETECTED";
                } else {
                    isHandVisible = false;
                    document.getElementById('status').innerText = "SEARCHING HAND...";
                }
            });

            const video = document.getElementById('v');
            const cam = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 320, height: 240 // 降低输入分辨率以提升AI计算速度
            });

            window.addEventListener('touchstart', () => {
                cam.start();
                document.getElementById('status').innerText = "CAMERA ON";
            }, {once: true});
        }

        resize();
        window.addEventListener('resize', resize);
        
        let loaded = 0;
        for(let i=1; i<=13; i++) {
            const img = new Image();
            img.crossOrigin = "anonymous";
            img.src = `mj/${i}.jpg`;
            img.onload = () => { if(++loaded === 13) { init(); animate(); } };
        }
    </script>
</body>
</html>
