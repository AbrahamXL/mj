<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>2026 NYE Gallery</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@1,400&family=Syncopate:wght@700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; }
        html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background: #000; position: fixed; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }
        
        /* UI Ê†∑Âºè‰ºòÂåñ */
        #ui { 
            position: absolute; top: 30px; left: 20px; z-index: 10; 
            pointer-events: none; text-align: left;
            transition: opacity 0.5s ease;
        }
        .year { 
            font-family: 'Syncopate', sans-serif;
            font-size: 14vw; font-weight: 700; 
            color: rgba(255,215,0,0.2); 
            margin: 0; line-height: 0.8;
            text-shadow: 0 0 20px rgba(255,215,0,0.1);
        }
        .subtitle {
            font-family: 'Playfair Display', serif;
            font-style: italic;
            font-size: 5vw; color: rgba(255, 255, 255, 0.5);
            margin-top: 5px; letter-spacing: 1px;
        }
        #status { 
            margin-top: 15px; color: #fff; font-size: 11px; 
            padding: 6px 10px; background: rgba(255,255,255,0.15); 
            display: inline-block; border-radius: 4px;
            font-family: sans-serif;
        }
        video { display: none; }
        /* ÊîæÂ§ßÊó∂ÈöêËóèUI */
        body.zooming #ui { opacity: 0; }
    </style>
</head>
<body>
    <div id="ui">
        <h1 class="year">2026</h1>
        <div class="subtitle">Happy New Year</div>
        <div id="status">ÁÇπÂáªÂ±èÂπïÂºÄÂêØÂ∫ÜÂÖ∏</div>
    </div>
    <canvas id="c"></canvas>
    <video id="v" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const totalPhotos = 10;
        let w, h, dpr, photos = [], particles = [], rockets = [];
        let handX = 0, isHandVisible = false, isPinching = false;
        let zoomLerp = 0, currentIdx = 0; 

        function resize() {
            w = window.innerWidth; h = window.innerHeight;
            dpr = Math.min(window.devicePixelRatio || 1, 2); 
            canvas.width = w * dpr; canvas.height = h * dpr;
            ctx.scale(dpr, dpr);
        }

        // --- ÁÉüËä±Á≤íÂ≠êÁ≥ªÁªü ---
        class Particle {
            constructor(x, y, hue) {
                this.x = x; this.y = y; this.hue = hue;
                this.alpha = 1; this.decay = 0.015 + Math.random() * 0.03;
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 7;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.gravity = 0.2;
            }
            update() {
                this.vx *= 0.96; this.vy *= 0.96; this.vy += this.gravity;
                this.x += this.vx; this.y += this.vy;
                this.alpha -= this.decay;
            }
            draw() {
                if (this.alpha <= 0) return;
                ctx.fillStyle = `hsla(${this.hue}, 100%, 60%, ${this.alpha})`;
                ctx.beginPath(); ctx.arc(this.x, this.y, 2.5, 0, Math.PI * 2); ctx.fill();
            }
        }

        class Rocket {
            constructor() {
                this.x = Math.random() * w; this.y = h;
                this.targetY = h * 0.15 + Math.random() * h * 0.3;
                this.hue = Math.random() * 360; this.speed = 18 + Math.random() * 5;
            }
            update() {
                this.y -= this.speed;
                if (this.y <= this.targetY) { this.explode(); return true; }
            }
            draw() {
                ctx.fillStyle = `hsl(${this.hue}, 100%, 70%)`;
                ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI * 2); ctx.fill();
            }
            explode() {
                for(let i=0; i<100; i++) particles.push(new Particle(this.x, this.y, this.hue));
            }
        }

        function animate() {
            // ‰ΩøÁî®ÂçäÈÄèÊòéÊ∏ÖÂ±èÔºåÂà∂ÈÄ†ÁÉüËä±ÊãñÂ∞æÊïàÊûú
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(0, 0, 15, 0.2)';
            ctx.fillRect(0, 0, w, h);

            // --- ÁªòÂà∂ÁÉüËä± ---
            ctx.globalCompositeOperation = 'lighter';
            // Â¶ÇÊûúÊ≠£Âú®ÊîæÂ§ßÊü•ÁúãÁÖßÁâáÔºåÂáèÂ∞ëÁÉüËä±ÂèëÂ∞ÑÈ¢ëÁéáÔºåÈÅøÂÖçÂπ≤Êâ∞
            let launchChance = zoomLerp > 0.2 ? 0.01 : 0.04;
            if (Math.random() < launchChance) rockets.push(new Rocket());
            
            rockets = rockets.filter(r => { r.draw(); return !r.update(); });
            particles = particles.filter(p => { p.update(); p.draw(); return p.alpha > 0; });

            // --- ÁªòÂà∂ÁÖßÁâáÂ¢ô ---
            ctx.globalCompositeOperation = 'source-over';
            if (photos.length > 0) {
                let targetIdx = isHandVisible ? handX * (photos.length - 1) : currentIdx;
                currentIdx += (targetIdx - currentIdx) * 0.35; 
                let targetZoom = isPinching ? 1 : 0;
                zoomLerp += (targetZoom - zoomLerp) * 0.3;

                if (zoomLerp > 0.1) document.body.classList.add('zooming');
                else document.body.classList.remove('zooming');

                photos.forEach((pData, i) => {
                    let diff = Math.abs(i - currentIdx);
                    let focus = Math.max(0, 1 - diff * 1.5); 
                    
                    ctx.save();
                    let baseAlpha = isHandVisible ? (0.15 + focus * 0.85) : 0.3;
                    if (focus < 0.8) baseAlpha *= (1 - zoomLerp * 1.5);
                    ctx.globalAlpha = Math.max(0, baseAlpha);
                    
                    if (ctx.globalAlpha < 0.01) { ctx.restore(); return; }

                    // Âü∫Á°Ä‰ΩçÁΩÆÁï•ÂæÆ‰∏ãÁßªÔºå‰∏∫ÊñáÂ≠óÁïôÁ©∫Èó¥
                    let bx = 30 + i * 15;
                    let by = 220 + i * 8; 
                    
                    if (focus > 0) {
                        bx += focus * 40 * (1 - zoomLerp) + (focus * zoomLerp * w * 0.2);
                        by += focus * 15 * (1 - zoomLerp) + (focus * zoomLerp * h * 0.1);
                    }
                    ctx.translate(bx, by);
                    
                    let baseScale = (w < 600 ? 0.22 : 0.4);
                    let s = baseScale + (focus * 0.2) + (focus * zoomLerp * 3.8);
                    let iw = pData.img.width * s;
                    let ih = pData.img.height * s;

                    ctx.drawImage(pData.img, 0, 0, iw, ih);
                    
                    if (zoomLerp > 0.1 && focus > 0.9) {
                        ctx.strokeStyle = `rgba(255, 215, 0, ${zoomLerp})`;
                        ctx.lineWidth = 3;
                        ctx.strokeRect(0, 0, iw, ih);
                    }
                    ctx.restore();
                });
            }
            requestAnimationFrame(animate);
        }

        async function init() {
            const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({
                maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5
            });
            
            hands.onResults(res => {
                if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                    isHandVisible = true;
                    const lm = res.multiHandLandmarks[0];
                    handX = 1 - lm[9].x; 
                    isPinching = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y) < 0.05;
                    document.getElementById('status').innerText = isPinching ? "‚ú® Ê≤âÊµ∏Êó∂Âàª ‚ú®" : "üëã Â∑≤ËøûÊé•ÊâãÂäø";
                } else {
                    isHandVisible = false;
                    document.getElementById('status').innerText = "üëÄ ÂØªÊâæÊâãÊéå‰∏≠...";
                }
            });

            const cam = new Camera(document.getElementById('v'), {
                onFrame: async () => { await hands.send({image: document.getElementById('v')}); },
                width: 320, height: 240
            });

            window.addEventListener('touchstart', () => {
                cam.start();
                document.getElementById('status').innerText = "üöÄ Â∫ÜÂÖ∏ÂêØÂä®‰∏≠...";
                // ÁÇπÂáªÂ±èÂπïÊó∂Á´ãÂàªÂèëÂ∞Ñ‰∏ÄÊûöÁÉüËä±Âä©ÂÖ¥
                rockets.push(new Rocket());
            }, {once: true});
        }

        resize();
        window.addEventListener('resize', resize);
        
        let loaded = 0;
        for(let i=1; i <= totalPhotos; i++) {
            const img = new Image(); img.crossOrigin = "anonymous"; img.src = `mj/${i}.jpg`;
            img.onload = () => { if(++loaded === totalPhotos) { init(); animate(); } };
        }
    </script>
</body>
</html>
