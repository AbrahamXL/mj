<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>2026 Gallery Corner</title>
    <link href="https://fonts.googleapis.com/css2?family=Syncopate:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; }
        html, body { 
            width: 100%; height: 100%; margin: 0; padding: 0; 
            overflow: hidden; background: #000; position: fixed; 
        }
        canvas { 
            position: absolute; top: 0; left: 0;
            width: 100% !important; height: 100% !important;
            display: block; 
        }
        /* UI 挪到左上角 */
        #ui { 
            position: absolute; top: 20px; left: 20px; 
            text-align: left; pointer-events: none; z-index: 10;
        }
        .year-display {
            font-size: 12vw; font-weight: 700; color: rgba(255, 255, 255, 0.2);
            -webkit-text-stroke: 1px rgba(255, 215, 0, 0.3); margin: 0;
        }
        #status {
            position: absolute; top: 12vw; left: 22px;
            color: rgba(255,255,255,0.5); font-size: 0.6rem; letter-spacing: 2px;
        }
        video { display: none; }
    </style>
</head>
<body>
    <div id="ui"><h1 class="year-display">2026</h1></div>
    <div id="status">TAP TO START</div>
    <canvas id="c"></canvas>
    <video id="v" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const folderName = "mj"; 
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        let w, h, dpr, photos = [], particles = [], rockets = [];
        let isStarMode = false, isPinching = false, handX = 0, handY = 0;
        let zoomLerp = 0, currentFocusIndex = 0;

        function resize() {
            w = window.innerWidth; h = window.innerHeight;
            dpr = window.devicePixelRatio || 1;
            canvas.width = Math.floor(w * dpr);
            canvas.height = Math.floor(h * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0); 
        }

        // 核心修改：投影中心点改在左上角 (80, 150)
        function project(x, y, z, rx, ry) {
            let x1 = x * Math.cos(ry) - z * Math.sin(ry);
            let z1 = x * Math.sin(ry) + z * Math.cos(ry);
            let y2 = y * Math.cos(rx) - z1 * Math.sin(rx);
            let z2 = y * Math.sin(rx) + z1 * Math.cos(rx);
            
            const fov = 600; 
            const s = fov / (fov + z2 + 500); 
            // 锚点设置在左上角区域
            return { x: x1 * s + 100, y: y2 * s + 250, s };
        }

        class Particle {
            constructor(x, y, z, hue) {
                this.x = x; this.y = y; this.z = z; this.hue = hue;
                this.alpha = 1;
                this.vx = (Math.random()-0.5)*10; this.vy = (Math.random()-0.5)*10;
            }
            update() {
                this.vx *= 0.96; this.vy *= 0.96; this.vy += 0.1;
                this.x += this.vx; this.y += this.vy;
                this.alpha -= 0.02;
            }
            draw() {
                if (this.alpha <= 0) return;
                const p = project(this.x, this.y, 0, 0, 0);
                ctx.fillStyle = `hsla(${this.hue}, 80%, 70%, ${this.alpha})`;
                ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI * 2); ctx.fill();
            }
        }

        function animate() {
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, w, h);
            
            // 烟花效果也改为在左上角附近触发
            if (!isStarMode && Math.random() < 0.05) {
                const hue = Math.random()*60;
                for(let i=0; i<30; i++) particles.push(new Particle((Math.random()-0.5)*100, (Math.random()-0.5)*100, 0, hue));
            }
            particles = particles.filter(p => { p.update(); p.draw(); return p.alpha > 0; });

            if (isStarMode && photos.length > 0) {
                zoomLerp += ((isPinching ? 1 : 0) - zoomLerp) * 0.1;
                let targetIdx = handX * (photos.length - 1);
                currentFocusIndex += (targetIdx - currentFocusIndex) * 0.1;

                photos.forEach((pData, i) => {
                    let diff = Math.abs(i - currentFocusIndex);
                    let focus = Math.max(0, 1 - diff * 0.8);
                    let active = Math.abs(i - Math.round(currentFocusIndex)) < 0.5;
                    
                    ctx.globalAlpha = (0.2 + focus * 0.8) * (1 - zoomLerp) + (active ? zoomLerp : 0);
                    
                    // 布局：向右下延伸的扇形
                    let zOff = active ? zoomLerp * 300 : 0;
                    let p = project(pData.x * (1-focus*0.5), pData.y * (1-focus*0.5), zOff, 0, 0);
                    
                    // 照片尺寸进一步缩小，确保左上角放得下
                    let scale = p.s * (0.3 + focus * 0.4 + (active ? zoomLerp * 0.4 : 0)) * (w < 600 ? 0.3 : 0.5);
                    let sw = pData.img.width * scale;
                    let sh = pData.img.height * scale;
                    
                    ctx.drawImage(pData.img, p.x, p.y, sw, sh);
                });
            }
            ctx.globalAlpha = 1;
            requestAnimationFrame(animate);
        }

        async function setup() {
            const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5});
            hands.onResults(res => {
                if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                    const lm = res.multiHandLandmarks[0];
                    handX = 1 - lm[9].x; handY = lm[9].y;
                    isStarMode = Math.hypot(lm[12].x-lm[0].x, lm[12].y-lm[0].y) > 0.3;
                    isPinching = isStarMode && Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.06;
                }
            });
            const video = document.getElementById('v');
            const cam = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 480, height: 640
            });
            window.addEventListener('touchstart', () => { cam.start(); document.getElementById('status').innerText="HAND SENSOR ACTIVE"; }, {once: true});
        }

        resize();
        window.addEventListener('resize', resize);
        
        for(let i=1; i<=13; i++) {
            const img = new Image(); img.crossOrigin = "anonymous";
            img.src = `${folderName}/${i}.jpg`;
            img.onload = () => {
                // 照片在 3D 空间向右下排列
                photos.push({img, x: i * 40, y: i * 30});
                if (photos.length === 13) { setup(); animate(); }
            };
        }
    </script>
</body>
</html>
