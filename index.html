<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>2026å…ƒæ—¦å¿«ä¹ - äº¤äº’å½±åƒè£…ç½®</title>
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+XiaoWei&family=Playfair+Display:ital,wght@1,900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Montserrat', sans-serif; }
        /* èƒŒæ™¯ç¨å¾®åŠ æ·±ä¸€ç‚¹ï¼Œçªå‡ºé‡‘è‰²çš„å¥¢åæ„Ÿ */
        #container { position: relative; width: 100vw; height: 100vh; background: radial-gradient(circle at center, #110000 0%, #000 100%); }
        
        #title-container {
            position: absolute; top: 10%; width: 100%; text-align: center; pointer-events: none; z-index: 10;
        }

        /* é…åˆæ–°è›‹ç³•ï¼Œè°ƒæ•´äº†æ–‡å­—çš„æ¸å˜è‰²ï¼Œå»æ‰äº†å†·è‰²è°ƒï¼Œå¼ºè°ƒæš–é‡‘å’Œå¥¶æ²¹è‰² */
        #main-title {
            font-family: 'ZCOOL XiaoWei', serif;
            font-weight: normal; margin: 0; padding: 0 20px; line-height: 1.2;
            color: transparent;
            background-image: linear-gradient(
                135deg,
                #FFFBE6 0%,    /* äº®å¥¶æ²¹ */
                #FFD700 30%,   /* çº¯é‡‘ */
                #E6C778 60%,   /* é¦™æ§Ÿé‡‘ */
                #C0A060 100%   /*æš—é‡‘ */
            );
            background-size: 200% auto;
            -webkit-background-clip: text;
            background-clip: text;
            text-shadow: 
                0px 2px 3px rgba(255,215,0,0.3),
                0px 10px 30px rgba(230, 150, 50, 0.2);
            animation: artisticShimmer 6s linear infinite alternate;
        }

        #main-title .year {
            font-family: 'Playfair Display', serif; font-style: italic; font-weight: 900;
            font-size: 7rem; display: block; filter: brightness(1.2);
        }

        #main-title .bless-1 { font-size: 4rem; display: block; letter-spacing: 0.2em; margin-top: -10px; }
        #main-title .bless-2 { font-size: 2.5rem; display: block; letter-spacing: 0.5em; opacity: 0.9; margin-top: 10px; }

        @keyframes artisticShimmer {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }

        #info-instructions {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.6); background: rgba(255,255,255,0.05); 
            padding: 12px 35px; border-radius: 50px; border: 1px solid rgba(255,215,0,0.2);
            backdrop-filter: blur(15px); font-size: 0.8rem; z-index: 100; letter-spacing: 2px;
        }
        
        #video-input { display: none; }
    </style>
</head>
<body>
    <div id="title-container">
        <h1 id="main-title">
            <span class="year">2026</span>
            <span class="bless-1">å…ƒæ—¦å¿«ä¹</span>
            <span class="bless-2">å­¦ä¸šæœ‰æˆ</span>
        </h1>
    </div>

    <div id="container">
        <div id="info-instructions">æ­£åœ¨å¯åŠ¨çš‡å®¶åº†å…¸è£…ç½®...</div>
        <video id="video-input" playsinline></video>
    </div>

    <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particleSystem, mainGroup, imageGroup;
        let treePos = [], starPos = [], currentPos = [];
        let morphFactor = 0, targetMorph = 0, targetRotX = 0, targetRotY = 0;

        const COUNT = 5800; // ç¨å¾®å¢åŠ ç²’å­æ•°ä»¥æ”¯æ’‘å¤æ‚çš„è£…é¥°
        const IMG_COUNT = 10;

        // è°ƒæ•´çº¹ç†ï¼Œè®©å…‰æ™•æ›´åæš–é‡‘è‰²
        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255,255,240,1)');
            grad.addColorStop(0.2, 'rgba(255,220,150,0.8)');
            grad.addColorStop(0.5, 'rgba(200,100,50,0.3)');
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 65;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            // ç…§ç‰‡ç¯
            imageGroup = new THREE.Group();
            mainGroup.add(imageGroup);
            const loader = new THREE.TextureLoader();
            for(let i=1; i<=IMG_COUNT; i++) {
                const texture = loader.load(`./mj/${i}.jpg`, undefined, undefined, () => {});
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(8, 10), material);
                const angle = ((i-1) / IMG_COUNT) * Math.PI * 2;
                mesh.position.set(Math.cos(angle) * 28, -2, Math.sin(angle) * 28); 
                mesh.lookAt(0, -2, 0); 
                imageGroup.add(mesh);
            }

            // --- å…¨æ–°è®¾è®¡çš„çš‡å®¶ä¸ç»’è›‹ç³• ---
            const geo = new THREE.BufferGeometry();
            const posArr = new Float32Array(COUNT * 3);
            const colArr = new Float32Array(COUNT * 3);
            const sizeArr = new Float32Array(COUNT);
            
            // è°ƒæ•´äº†å±‚é«˜æ¯”ä¾‹ï¼Œè®©å®ƒçœ‹èµ·æ¥æ›´æŒºæ‹”
            const tiers = [{ r: 13, h: 6, y: -14 }, { r: 9, h: 5, y: -8 }, { r: 5.5, h: 4, y: -3 }];
            
            // å…¨æ–°é…è‰²ç›˜
            const palette = {
                velvetRed: new THREE.Color(0x720015),   // å‹ƒè‰®ç¬¬æ·±çº¢ä¸ç»’
                brightGold: new THREE.Color(0xFFD700),  // äº®é‡‘è£…é¥°
                champagne: new THREE.Color(0xE6C778),   // é¦™æ§Ÿé‡‘æµè‹
                flameCore: new THREE.Color(0xFFF7BB)    // åœ£ç«æ ¸å¿ƒ
            };

            for(let i=0; i<COUNT; i++) {
                let vTree = new THREE.Vector3();
                let pColor = new THREE.Color();
                let pSize = 0.6;
                let angle = Math.random() * Math.PI * 2;

                // --- è£…é¥°éƒ¨åˆ† (ä¼˜å…ˆåˆ†é…ç²’å­) ---

                if (i < 1200) { 
                    // === ä¸­å±‚ï¼šæµé‡‘ç€‘å¸ƒ (Molten Gold Cascade) ===
                    const t = tiers[1];
                    angle = Math.random() * Math.PI * 2;
                    // ç²’å­é›†ä¸­åœ¨é¡¶éƒ¨è¾¹ç¼˜ï¼Œç„¶åéšæœºå‘ä¸‹æµæ·Œ
                    const dripHeight = Math.random() * Math.random() * t.h * 1.2; // éšæœºæµæ·Œé•¿åº¦
                    const r = t.r * (1.02 + Math.random()*0.05); // ç¨å¾®æµ®åœ¨è¡¨é¢
                    vTree.set(r * Math.cos(angle), t.y + t.h - dripHeight, r * Math.sin(angle));
                    
                    // é¢œè‰²ï¼šé¡¶éƒ¨æ›´äº®é‡‘ï¼Œåº•éƒ¨åé¦™æ§Ÿè‰²
                    pColor.lerpColors(palette.champagne, palette.brightGold, 1 - dripHeight/(t.h*1.2));
                    pSize = 0.5 + Math.random() * 0.4; // å¤§å°ä¸ä¸€çš„æ¶²æ»´æ„Ÿ
                } 
                else if (i < 2000) {
                    // === åº•å±‚ï¼šè±æ ¼çº¹é‡‘é¥° (Quilted Gold) ===
                    const t = tiers[0];
                    // åˆ›å»ºç½‘æ ¼åˆ†å¸ƒ
                    const rows = 8; const cols = 24;
                    const rowIdx = Math.floor(Math.random() * rows);
                    const colIdx = Math.floor(Math.random() * cols);
                    
                    angle = (colIdx / cols) * Math.PI * 2;
                    const hRel = rowIdx / rows;
                    
                    // åœ¨ç½‘æ ¼äº¤å‰ç‚¹æ”¾ç½®é‡‘è‰²é“†é’‰
                    const r = t.r * 1.03;
                    vTree.set(r * Math.cos(angle), t.y + hRel * t.h, r * Math.sin(angle));
                    pColor.copy(palette.brightGold);
                    pSize = 0.9; // è¾ƒå¤§çš„é‡‘è‰²é“†é’‰
                    // ç¨å¾®é”™ä½ä¸€ç‚¹ï¼Œå¢åŠ è‡ªç„¶æ„Ÿ
                    vTree.x += (Math.random()-0.5)*0.5; vTree.y += (Math.random()-0.5)*0.5; vTree.z += (Math.random()-0.5)*0.5;
                }
                else if (i < 2600) {
                    // === é¡¶å±‚ï¼šé‡‘è‰²çš‡å† ä¸åœ£ç« (Crown & Flame) ===
                    const t = tiers[2];
                    angle = Math.random() * Math.PI * 2;
                    if (Math.random() > 0.3) {
                        // çš‡å† ä¸»ä½“ç»“æ„ (æ³¢æµªå½¢è¾¹ç¼˜)
                        const crownHeight = 3;
                        const wave = Math.abs(Math.sin(angle * 4)) * 1.5; // 8ä¸ªå°–è§’
                        const r = t.r * (0.8 + Math.random()*0.2);
                        vTree.set(r * Math.cos(angle), t.y + t.h + Math.random() * (crownHeight + wave), r * Math.sin(angle));
                        pColor.copy(palette.brightGold);
                        pSize = 0.6;
                    } else {
                        // ä¸­å¿ƒåœ£ç«
                        const r = Math.random() * 1.5;
                        vTree.set(r * Math.cos(angle), t.y + t.h + 1 + Math.random() * 4, r * Math.sin(angle));
                        pColor.copy(palette.flameCore);
                        pSize = 1.2; // æ˜äº®çš„å¤§æ ¸å¿ƒ
                        vTree.x *= (1 - (vTree.y - (t.y + t.h))/4); // æ”¶æŸæˆç«ç„°å½¢çŠ¶
                        vTree.z *= (1 - (vTree.y - (t.y + t.h))/4);
                    }
                }
                
                // --- è›‹ç³•ä¸»ä½“å¡«å…… ---
                else {
                    let t = i < COUNT * 0.75 ? tiers[0] : (i < COUNT * 0.9 ? tiers[1] : tiers[2]);
                    // ä¸»ä½“ç¨å¾®å†…æ”¶ä¸€ç‚¹ï¼Œè®©è£…é¥°çªå‡ºæ¥
                    const r = t.r * (0.88 + Math.random() * 0.1);
                    const hRel = Math.random();
                    vTree.set(r * Math.cos(angle), t.y + hRel * t.h, r * Math.sin(angle));
                    
                    // æ·±çº¢ä¸ç»’åŸºåº•ï¼Œå¸¦æœ‰å¾®å¦™çš„æ˜æš—å˜åŒ–å¢åŠ è´¨æ„Ÿ
                    pColor.copy(palette.velvetRed);
                    pColor.multiplyScalar(0.8 + hRel * 0.4); 
                    pSize = 0.7;
                }

                treePos.push(vTree.clone());
                starPos.push(new THREE.Vector3().setFromSphericalCoords(50 + Math.random()*30, Math.random()*Math.PI, Math.random()*Math.PI*2));
                currentPos.push(vTree.clone());
                posArr[i*3] = vTree.x; posArr[i*3+1] = vTree.y; posArr[i*3+2] = vTree.z;
                colArr[i*3] = pColor.r; colArr[i*3+1] = pColor.g; colArr[i*3+2] = pColor.b;
                sizeArr[i] = pSize;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(sizeArr, 1));

            // å¼€å¯ sizeAttenuation è®©é‡‘è‰²è£…é¥°ç²’å­çœ‹èµ·æ¥æ›´é—ªäº®
            particleSystem = new THREE.Points(geo, new THREE.PointsMaterial({ 
                size: 1.2, map: createStarTexture(), transparent: true, blending: THREE.AdditiveBlending, 
                vertexColors: true, depthWrite: false, sizeAttenuation: true 
            }));
            mainGroup.add(particleSystem);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = Date.now();
            morphFactor = THREE.MathUtils.lerp(morphFactor, targetMorph, 0.2);
            
            mainGroup.rotation.y += 0.002;
            mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, targetRotY, 0.1);
            mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, targetRotX, 0.1);

            imageGroup.children.forEach((mesh) => {
                mesh.material.opacity = THREE.MathUtils.lerp(0, 0.8, (morphFactor - 0.2) * 5);
                mesh.scale.setScalar(THREE.MathUtils.clamp(morphFactor * 1.1, 0.01, 1.1));
            });

            const posAttr = particleSystem.geometry.attributes.position;
            const sizeAttr = particleSystem.geometry.attributes.size;
            for(let i=0; i<COUNT; i++) {
                currentPos[i].lerpVectors(treePos[i], starPos[i], morphFactor);
                posAttr.array[i*3] = currentPos[i].x;
                
                // ä¸åŒçš„ç²’å­æœ‰ä¸åŒçš„åŠ¨æ€æ•ˆæœ
                let wave = 0;
                if (i < 1200) wave = Math.sin(now * 0.003 + i) * 0.08; // æµé‡‘ç€‘å¸ƒæµåŠ¨æ„Ÿæ›´å¼º
                else if (i >= 2000 && i < 2600) wave = Math.sin(now * 0.005 + i) * 0.12; // çš‡å† ç«ç„°é—ªçƒ
                else wave = Math.sin(now * 0.001 + i) * 0.03; // ä¸»ä½“ç¼“æ…¢å‘¼å¸

                posAttr.array[i*3+1] = currentPos[i].y + wave;
                posAttr.array[i*3+2] = currentPos[i].z;

                // èšåˆæ—¶è®©é‡‘è‰²è£…é¥°ç²’å­é—ªçƒ
                if (morphFactor < 0.3 && i < 2600) {
                     sizeAttr.array[i] = sizeArr[i] * (1 + Math.sin(now * 0.005 + i)*0.2);
                }
            }
            posAttr.needsUpdate = true;
            sizeAttr.needsUpdate = true;
            renderer.render(scene, camera);
        }

        async function startAI() {
            const info = document.getElementById('info-instructions');
            try {
                const hands = new Hands({ locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}` });
                hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
                
                hands.onResults(res => {
                    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                        const h = res.multiHandLandmarks[0];
                        const fingers = [8, 12, 16, 20];
                        let openCount = 0;
                        fingers.forEach(tip => { if (h[tip].y < h[tip-2].y) openCount++; });
                        targetMorph = openCount / 4;
                        targetRotY = (0.5 - h[9].x) * 6;
                        targetRotX = (h[9].y - 0.5) * 3;
                        info.innerHTML = morphFactor > 0.4 ? "âœ¨ è®°å¿†æ˜Ÿæ²³å·²å¼€å¯" : "ğŸ–ï¸ å¼ å¼€æ‰‹æŒï¼Œé‡Šæ”¾ç¥ç¦";
                    } else {
                        info.innerText = "ğŸ‘‹ æŒ¥æ‰‹å¼€å¯çš‡å®¶åº†å…¸";
                    }
                });

                const cam = new Camera(document.getElementById('video-input'), {
                    onFrame: async () => { await hands.send({ image: document.getElementById('video-input') }); },
                    width: 640, height: 480
                });
                cam.start();
            } catch(e) {
                info.innerText = "âš ï¸ æ‘„åƒå¤´è¿è¡Œå¼‚å¸¸";
            }
        }

        window.onload = () => { init(); startAI(); };
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
