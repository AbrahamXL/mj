<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>2026å…ƒæ—¦å¿«ä¹ - äº¤äº’å½±åƒè£…ç½®</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@1,800&family=Montserrat:wght@300&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Montserrat', sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; background: radial-gradient(circle at center, #0a0a1a 0%, #000 100%); }
        
        #title-container {
            position: absolute; top: 10%; width: 100%; text-align: center;
            pointer-events: none; z-index: 10;
        }

        /* --- æ ¸å¿ƒä¿®æ”¹ï¼šè‰ºæœ¯æ„Ÿå­—ä½“è®¾è®¡ --- */
        #main-title {
            /* 1. å­—ä½“æ ˆï¼šä¼˜å…ˆä½¿ç”¨æ›´æœ‰è‰ºæœ¯æ„Ÿçš„è¡¬çº¿ä½“/å®‹ä½“ï¼Œå›é€€åˆ°ç³»ç»Ÿå®‹ä½“ */
            font-family: 'Playfair Display', 'Noto Serif SC', 'Source Han Serif SC', 'SimSun', serif;
            font-size: 5rem; 
            font-weight: 800; /* ç‰¹ç²—å­—é‡å¢å¼ºè´¨æ„Ÿ */
            letter-spacing: 0.12em; /* å¢åŠ å­—é—´è·è¥é€ å®å¤§æ„Ÿ */
            margin: 0;
            line-height: 1.2;

            /* 2. æè´¨ï¼šå¤æ‚çš„æ¶²æ€æµå…‰é‡‘çº¹ç† */
            background: linear-gradient(
                110deg,
                #9E7E38 10%,   /* æ·±æ²‰æš—é‡‘ */
                #F3E2A9 30%,   /* æŸ”å’Œäº®é‡‘ */
                #FFFFFF 50%,   /* çº¯ç™½æ ¸å¿ƒé«˜å…‰ */
                #F3E2A9 70%,   /* æŸ”å’Œäº®é‡‘ */
                #9E7E38 90%    /* æ·±æ²‰æš—é‡‘ */
            );
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;

            /* 3. æè¾¹ï¼šå¢åŠ ç²¾è‡´çš„é‡‘å±è¾¹ç¼˜å…‰ */
            -webkit-text-stroke: 1px rgba(255, 245, 220, 0.3);

            /* 4. å…‰æ™•ï¼šå¤šé‡å…‰å½±å åŠ ï¼Œè¥é€ å¥¢åæ°›å›´ */
            filter: 
                drop-shadow(0 0 15px rgba(255, 215, 0, 0.7)) /* å†…å±‚é«˜äº®å…‰æ™• */
                drop-shadow(0 0 60px rgba(255, 180, 50, 0.4)); /* å¤–å±‚æŸ”å’Œæ¼«å°„å…‰ */

            /* åŠ¨ç”»ï¼šä½¿ç”¨æ–°çš„å¹³æ»‘æ‰«å…‰åŠ¨ç”» */
            animation: textShine 5s linear infinite; 
        }

        /* æ–°çš„æ‰«å…‰åŠ¨ç”»å…³é”®å¸§ */
        @keyframes textShine {
            0% { background-position: 0% center; }
            100% { background-position: -200% center; }
        }
        /* --------------------------------- */


        #info-instructions {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.8); background: rgba(0,0,0,0.5); 
            padding: 12px 35px; border-radius: 50px; border: 1px solid rgba(255,215,0,0.3);
            backdrop-filter: blur(15px); font-size: 0.9rem; z-index: 100; letter-spacing: 1px;
            white-space: nowrap;
        }
        
        #reticle {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 24px; height: 24px; border: 2px solid rgba(255,215,0,0.6);
            border-radius: 50%; pointer-events: none; z-index: 50; display: none;
        }
        #reticle::after {
            content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 4px; height: 4px; background: #ffd700; border-radius: 50%;
        }

        #video-input { display: none; }
    </style>
</head>
<body>
    <div id="reticle"></div>
    <div id="title-container">
        <h1 id="main-title">2026å…ƒæ—¦å¿«ä¹</h1>
    </div>
    
    <div id="container">
        <div id="info-instructions">æ­£åœ¨è¯»å–å½±åƒåºåˆ—...</div>
        <video id="video-input" playsinline></video>
    </div>

    <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particleSystem, mainGroup, snowSystem, imageGroup;
        let treePos = [], starPos = [], currentPos = [], targetColors = [], currentColors = [];
        let morphFactor = 0, targetMorph = 0, targetRotX = 0, targetRotY = 0;
        let lastColorChange = 0, zoomedImage = null, selectedImage = null;

        const COUNT = 3500;
        const IMG_COUNT = 10;

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'white'); grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            // å›¾ç‰‡åŠ è½½
            imageGroup = new THREE.Group();
            mainGroup.add(imageGroup);
            const loader = new THREE.TextureLoader();
            
            for(let i=1; i<=IMG_COUNT; i++) {
                // ç¡®ä¿ä½ çš„ mj æ–‡ä»¶å¤¹å’Œè¿™ä¸ª html åœ¨åŒä¸€çº§ç›®å½•
                const texture = loader.load(`./mj/${i}.jpg`, (tex) => {
                    const aspect = tex.image.width / tex.image.height;
                    mesh.geometry = new THREE.PlaneGeometry(7 * aspect, 7);
                });

                const material = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    transparent: true, 
                    opacity: 0,
                    side: THREE.DoubleSide,
                    depthTest: true
                });
                
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(6, 9), material);
                mesh.renderOrder = 0; 

                const angle = ((i-1) / IMG_COUNT) * Math.PI * 2;
                const radius = 18;
                mesh.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                mesh.lookAt(0, 0, 0); 
                mesh.userData = { originalPos: mesh.position.clone(), originalRot: mesh.rotation.clone() };
                imageGroup.add(mesh);
            }

            // ç²’å­ç³»ç»Ÿ (è›‹ç³•)
            const geo = new THREE.BufferGeometry();
            const posArr = new Float32Array(COUNT * 3);
            const colArr = new Float32Array(COUNT * 3);
            const tiers = [{ r: 12, h: 5.5, y: -10 }, { r: 8.5, h: 5.5, y: -4.5 }, { r: 5, h: 5.5, y: 1.0 }];

            for(let i=0; i<COUNT; i++) {
                let vTree = new THREE.Vector3();
                let pColor = new THREE.Color();
                let tierIdx = i < COUNT*0.4 ? 0 : (i < COUNT*0.8 ? 1 : 2);
                const t = tiers[tierIdx];
                const angle = Math.random() * Math.PI * 2;
                
                if (Math.random() > 0.3) {
                    const r = t.r * (0.95 + Math.random()*0.1);
                    vTree.set(r * Math.cos(angle), t.y + Math.random()*t.h, r * Math.sin(angle));
                    pColor.setHex(0xFFFDD0);
                } else {
                    const r = Math.sqrt(Math.random()) * t.r;
                    vTree.set(r * Math.cos(angle), t.y + t.h, r * Math.sin(angle));
                    pColor.setHex(0xFFFFFF);
                }

                treePos.push(vTree);
                starPos.push(new THREE.Vector3().setFromSphericalCoords(30 + Math.random()*20, Math.random()*Math.PI, Math.random()*Math.PI*2));
                currentPos.push(vTree.clone());
                targetColors.push(pColor.clone());
                currentColors.push(pColor.clone());
                posArr[i*3] = vTree.x; posArr[i*3+1] = vTree.y; posArr[i*3+2] = vTree.z;
                colArr[i*3] = pColor.r; colArr[i*3+1] = pColor.g; colArr[i*3+2] = pColor.b;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
            particleSystem = new THREE.Points(geo, new THREE.PointsMaterial({ size: 0.6, map: createStarTexture(), transparent: true, blending: THREE.AdditiveBlending, vertexColors: true, depthWrite: false }));
            mainGroup.add(particleSystem);

            // é›ªèŠ±
            const snowGeo = new THREE.BufferGeometry();
            const snowPosArr = new Float32Array(800 * 3);
            for(let i=0; i<800*3; i++) snowPosArr[i] = (Math.random()-0.5)*120;
            snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPosArr, 3));
            snowSystem = new THREE.Points(snowGeo, new THREE.PointsMaterial({ size: 0.3, color: 0xffffff, transparent: true, opacity: 0.4 }));
            scene.add(snowSystem);

            animate();
        }

        const raycaster = new THREE.Raycaster();
        const centerScreen = new THREE.Vector2(0, 0);

        function animate() {
            requestAnimationFrame(animate);
            const now = Date.now();
            
            morphFactor = THREE.MathUtils.lerp(morphFactor, targetMorph, 0.05);
            mainGroup.rotation.y += 0.002;
            mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, targetRotY, 0.05);
            mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, targetRotX, 0.05);

            const isOpened = morphFactor > 0.5;
            document.getElementById('reticle').style.display = (isOpened && !zoomedImage) ? 'block' : 'none';

            // å›¾ç‰‡æ¸²æŸ“é€»è¾‘ (ä¿æŒæœ€å‰)
            imageGroup.children.forEach((mesh) => {
                if (zoomedImage === mesh) {
                    const targetPos = new THREE.Vector3(0, 0, 40);
                    mesh.position.lerp(targetPos, 0.1);
                    mesh.rotation.set(0, 0, 0);
                    mesh.material.opacity = 1;
                    mesh.material.depthTest = false; 
                    mesh.renderOrder = 999; 
                } else if (zoomedImage) {
                    mesh.material.opacity = THREE.MathUtils.lerp(mesh.material.opacity, 0, 0.1);
                } else {
                    mesh.material.depthTest = true;
                    mesh.renderOrder = 0;
                    mesh.material.opacity = THREE.MathUtils.lerp(0, 0.9, (morphFactor - 0.3) * 2);
                    mesh.scale.setScalar(THREE.MathUtils.clamp(morphFactor * 1.2, 0.01, 1.2));
                    mesh.position.lerp(mesh.userData.originalPos, 0.05);
                    mesh.rotation.copy(mesh.userData.originalRot);
                }
            });

            if (isOpened && !zoomedImage) {
                raycaster.setFromCamera(centerScreen, camera);
                const intersects = raycaster.intersectObjects(imageGroup.children);
                if (intersects.length > 0) {
                    if (selectedImage !== intersects[0].object) {
                        if (selectedImage) selectedImage.scale.multiplyScalar(0.8);
                        selectedImage = intersects[0].object;
                        selectedImage.scale.multiplyScalar(1.25);
                    }
                } else {
                    if (selectedImage) selectedImage.scale.setScalar(1.2);
                    selectedImage = null;
                }
            }

            const posAttr = particleSystem.geometry.attributes.position;
            for(let i=0; i<COUNT; i++) {
                currentPos[i].lerpVectors(treePos[i], starPos[i], morphFactor);
                posAttr.array[i*3] = currentPos[i].x;
                posAttr.array[i*3+1] = currentPos[i].y + Math.sin(now*0.001+i)*0.03;
                posAttr.array[i*3+2] = currentPos[i].z;
            }
            posAttr.needsUpdate = true;

            renderer.render(scene, camera);
        }

        async function startAI() {
            const info = document.getElementById('info-instructions');
            const hands = new Hands({ locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
            
            hands.onResults(res => {
                if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                    const h = res.multiHandLandmarks[0];
                    const fingers = [8, 12, 16, 20];
                    let openCount = 0;
                    fingers.forEach(tip => { if (h[tip].y < h[tip-2].y) openCount++; });
                    targetMorph = openCount / 4;

                    targetRotY = (0.5 - h[9].x) * 12;
                    targetRotX = (h[9].y - 0.5) * 6;

                    const distPinch = Math.hypot(h[4].x - h[8].x, h[4].y - h[8].y);
                    if (distPinch < 0.05 && selectedImage && !zoomedImage) {
                        zoomedImage = selectedImage;
                    }

                    if (openCount >= 3 && zoomedImage && distPinch > 0.15) {
                        zoomedImage = null;
                    }

                    if (zoomedImage) {
                        info.innerHTML = "âœ¨ å½±åƒå·²èšç„¦ | å…¨å¼ å¼€æ‰‹æŒä»¥é€€å‡º";
                    } else if (morphFactor > 0.5) {
                        info.innerHTML = "ğŸ¯ è½¬åŠ¨è§†è§’ä½¿å‡†å¿ƒå¯¹å‡†å›¾ç‰‡ï¼Œç„¶åã€æåˆæŒ‡å°–ã€‘";
                    } else {
                        info.innerHTML = "ğŸ–ï¸ å±•ç¤ºæ‰‹æŒå¹¶æ…¢æ…¢å¼ å¼€ï¼Œå”¤é†’è®°å¿†ç¢ç‰‡";
                    }
                } else {
                    info.innerText = "âœ¨ è¯·å±•ç¤ºæ‰‹æŒå¼€å¯äº¤äº’";
                }
            });

            const cam = new Camera(document.getElementById('video-input'), {
                onFrame: async () => { await hands.send({ image: document.getElementById('video-input') }); },
                width: 640, height: 480
            });
            cam.start();
        }

        window.onload = () => { init(); startAI(); };
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
