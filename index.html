<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>2026 New Year Cake</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&family=Playfair+Display:ital,wght@1,700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; }
        html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background: #020205; position: fixed; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }
        #ui { 
            position: absolute; top: 40px; left: 0; width: 100%; z-index: 10; 
            pointer-events: none; transition: opacity 0.8s ease, transform 0.8s ease; text-align: center;
        }
        .year { 
            font-family: 'Cinzel Decorative', cursive;
            font-size: 15vw; color: rgba(255,230,150,0.4); 
            margin: 0; line-height: 0.8; text-shadow: 0 0 30px rgba(255,200,50,0.3);
        }
        .subtitle {
            font-family: 'Playfair Display', serif; font-weight: 700;
            font-size: 6vw; color: rgba(255, 230, 180, 0.9); margin-top: 15px; letter-spacing: 3px;
            text-shadow: 0 0 10px rgba(255,215,0,0.5);
        }
        #status { 
            margin-top: 25px; color: rgba(255,255,255,0.8); font-size: 12px; 
            padding: 6px 12px; background: rgba(50,50,50,0.3); 
            display: inline-block; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1);
            font-family: sans-serif; transition: opacity 0.3s;
        }
        video { display: none; }
        /* æ•£å¼€ç…§ç‰‡æ—¶ï¼ŒUI æ·¡å‡º */
        body.scattering #ui { opacity: 0; transform: translateY(-30px); }
    </style>
</head>
<body>
    <div id="ui">
        <h1 class="year">2026</h1>
        <div class="subtitle">å…ƒæ—¦å¿«ä¹</div>
        <div id="status">æ­£åœ¨ç­¹å¤‡åº†å…¸...</div>
    </div>
    <canvas id="c"></canvas>
    <video id="v" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const totalPhotos = 10;
        let w, h, dpr;
        let photos = [], bgStars = [], explosions = [], cakeParticles = [];
        let isHandVisible = false, isPinching = false;
        // æ ¸å¿ƒä¿®æ”¹1: åˆå§‹ gatherLerp è®¾ä¸º 1ï¼Œå³åˆå§‹çŠ¶æ€ä¸ºèšæ‹¢çš„è›‹ç³•
        let gatherLerp = 1, time = 0;

        function resize() {
            w = window.innerWidth; h = window.innerHeight;
            dpr = Math.min(window.devicePixelRatio || 1, 2);
            canvas.width = w * dpr; canvas.height = h * dpr;
            ctx.scale(dpr, dpr);
            initParticles();
        }

        function getCylinderPoint(radius, heightBot, heightTop) {
            let a = Math.random() * Math.PI * 2;
            let h = heightBot + Math.random() * (heightTop - heightBot);
            let r = radius + (Math.random() - 0.5) * 5;
            return { x: Math.cos(a) * r, y: h, z: Math.sin(a) * r };
        }

        function initParticles() {
            bgStars = []; cakeParticles = [];
            for(let i=0; i<150; i++) {
                bgStars.push({x:(Math.random()-0.5)*w*3, y:(Math.random()-0.5)*h*3, z:Math.random()*1500, size:Math.random()*2.5, hue:200+Math.random()*60});
            }

            const addParticle = (target, type) => {
                let hue, saturation, lightness, sizeBase;
                if (type === 'base') { hue = 35 + Math.random() * 15; saturation = '80%'; lightness = '70%'; sizeBase = 1.5; }
                else if (type === 'rim') { hue = 45 + Math.random() * 5; saturation = '100%'; lightness = '85%'; sizeBase = 2.5; }
                else if (type === 'gem') { hue = Math.random() < 0.7 ? 0 : 200; saturation = '90%'; lightness = '60%'; sizeBase = 3.5; }

                cakeParticles.push({
                    scatterX: (Math.random()-0.5)*w*2, scatterY: (Math.random()-0.5)*h*2, scatterZ: Math.random()*1000,
                    targetX: target.x, targetY: target.y, targetZ: target.z,
                    color: `hsla(${hue}, ${saturation}, ${lightness}, `,
                    size: sizeBase + Math.random() * 1.5,
                    speedOffset: Math.random() * Math.PI * 2,
                    type: type
                });
            };

            for(let i=0; i<1500; i++) addParticle(getCylinderPoint(200, 100, 220), 'base');
            for(let i=0; i<300; i++) { let a = (i/300)*Math.PI*2; addParticle({x:Math.cos(a)*205, y:100, z:Math.sin(a)*205}, 'rim'); if(i%10===0) addParticle({x:Math.cos(a)*205, y:100, z:Math.sin(a)*205}, 'gem'); }
            for(let i=0; i<1000; i++) addParticle(getCylinderPoint(130, -20, 100), 'base');
            for(let i=0; i<250; i++) { let a = (i/250)*Math.PI*2; addParticle({x:Math.cos(a)*135, y:-20, z:Math.sin(a)*135}, 'rim'); }
            for(let i=0; i<600; i++) addParticle(getCylinderPoint(70, -100, -20), 'base');
            for(let i=0; i<150; i++) { let a = Math.random()*Math.PI*2, r = Math.random()*30; addParticle({x:Math.cos(a)*r, y:-120 - Math.random()*40, z:Math.sin(a)*r}, 'rim'); }
        }

        function project(x, y, z) {
            const fov = 700; const s = fov / (fov + z);
            return { x: x * s + w/2, y: y * s + h/2, scale: s };
        }

        class Explosion {
            constructor(x, y) {
                this.p = [];
                for(let i=0; i<50; i++) {
                    let a=Math.random()*Math.PI*2, spd=Math.random()*8;
                    this.p.push({x, y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, alpha:1, hue: 40+Math.random()*20});
                }
            }
            update() { this.p.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.vy+=0.15;p.alpha-=0.025;}); this.p=this.p.filter(p=>p.alpha>0); }
            draw() { this.p.forEach(p=>{ctx.fillStyle=`hsla(${p.hue},100%,70%,${p.alpha})`;ctx.beginPath();ctx.arc(p.x,p.y,2.5,0,Math.PI*2);ctx.fill();}); }
        }

        function animate() {
            time += 0.02;
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(8, 5, 16, 0.3)'; 
            ctx.fillRect(0, 0, w, h);

            // æ ¸å¿ƒä¿®æ”¹2: äº¤äº’é€»è¾‘åè½¬
            // åªæœ‰åœ¨æ£€æµ‹åˆ°æ‰‹ä¸”å¼ å¼€æ—¶ï¼Œç›®æ ‡æ‰æ˜¯æ•£å¼€(0)ï¼Œå¦åˆ™ä¿æŒèšæ‹¢(1)
            let targetGather = (isHandVisible && !isPinching) ? 0 : 1;
            gatherLerp += (targetGather - gatherLerp) * 0.08;

            // UI æ§åˆ¶ï¼šå½“å¼€å§‹æ•£å¼€æ—¶ï¼ŒUIæ·¡å‡º
            if(gatherLerp < 0.9) document.body.classList.add('scattering');
            else document.body.classList.remove('scattering');

            let rot = time * 0.6;
            let tilt = Math.sin(time*0.4) * 0.1;

            ctx.globalCompositeOperation = 'lighter'; 

            bgStars.forEach(s => {
                s.z-=2; if(s.z<0) s.z=1500;
                let p=project(s.x, s.y, s.z);
                ctx.fillStyle=`hsla(${s.hue},60%,40%,${0.5*(1-s.z/1500)})`;
                ctx.beginPath();ctx.arc(p.x,p.y,s.size*p.scale,0,Math.PI*2);ctx.fill();
            });

            cakeParticles.sort((a, b) => b.curZ - a.curZ);
            cakeParticles.forEach(cp => {
                let tx = cp.targetX*Math.cos(rot) - cp.targetZ*Math.sin(rot);
                let tz = cp.targetX*Math.sin(rot) + cp.targetZ*Math.cos(rot);
                let ty = cp.targetY + tz * tilt; 
                tx = tx * Math.cos(tilt);

                let x = cp.scatterX + (tx - cp.scatterX) * gatherLerp;
                let y = cp.scatterY + (ty - cp.scatterY) * gatherLerp;
                let z = cp.scatterZ + (tz - cp.scatterZ) * gatherLerp;
                cp.curZ = z;

                let p = project(x, y, z);
                
                let baseAlpha = 0.2 + gatherLerp * 0.8;
                let flicker = 0.8 + Math.sin(time*3 + cp.speedOffset)*0.2;
                let alpha = baseAlpha * flicker;
                if (cp.type === 'rim' || cp.type === 'gem') alpha = Math.min(1, alpha * 1.5);

                ctx.fillStyle = cp.color + alpha + ')';
                ctx.beginPath();
                let size = cp.size * p.scale * (0.8 + gatherLerp*0.4);
                ctx.arc(p.x, p.y, size, 0, Math.PI*2);
                ctx.fill();
            });

            // çƒŸèŠ±é€»è¾‘ä¿®æ”¹ï¼šåœ¨æ•£å¼€çš„è¿‡ç¨‹ä¸­è§¦å‘
            if (isHandVisible && !isPinching && gatherLerp < 0.8 && gatherLerp > 0.2 && Math.random() < 0.1) {
                explosions.push(new Explosion(w/2 + (Math.random()-0.5)*300, h/2 + (Math.random()-0.5)*300));
            }
            explosions.forEach(e => { e.update(); e.draw(); });
            explosions = explosions.filter(e => e.p.length > 0);

            ctx.globalCompositeOperation = 'source-over';
            if (photos.length > 0) {
                // ç…§ç‰‡å¯è§æ€§å…¬å¼ä¸å˜ï¼šèšæ‹¢æ—¶éšè—ï¼Œæ•£å¼€æ—¶æ˜¾ç¤º
                let visibility = Math.pow(Math.max(0, 1 - gatherLerp * 1.5), 3);
                if (visibility > 0.01) {
                    photos.forEach((pData, i) => {
                        let sx = pData.seedX + Math.sin(time+i)*40;
                        let sy = pData.seedY + Math.cos(time+i)*40;
                        let sz = pData.seedZ;
                        let p = project(sx, sy, sz);
                        
                        ctx.save();
                        ctx.globalAlpha = visibility * 0.8;
                        ctx.translate(p.x, p.y);
                        let s = p.scale * 0.28;
                        ctx.drawImage(pData.img, -pData.img.width*s/2, -pData.img.height*s/2, pData.img.width*s, pData.img.height*s);
                        ctx.strokeStyle = `rgba(255,215,0,${visibility})`; ctx.lineWidth = 1;
                        ctx.strokeRect(-pData.img.width*s/2, -pData.img.height*s/2, pData.img.width*s, pData.img.height*s);
                        ctx.restore();
                    });
                }
            }
            requestAnimationFrame(animate);
        }

        async function initAI() {
            document.getElementById('status').innerText = "âœ¨ æ­£åœ¨å”¤é†’æ˜Ÿè¾°...";
            const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5});
            hands.onResults(res => {
                if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                    isHandVisible = true;
                    const lm = res.multiHandLandmarks[0];
                    isPinching = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y) < 0.06;
                    // æ›´æ–°çŠ¶æ€æ–‡æ¡ˆ
                    document.getElementById('status').innerText = isPinching ? "ğŸ‚ è›‹ç³•å·²èšæ‹¢" : "ğŸ‰ å¼ å¼€æ‰‹æŒï¼Œæ˜¾ç°æƒŠå–œ";
                } else {
                    isHandVisible = false; isPinching = false;
                    document.getElementById('status').innerText = "ğŸ‘€ å¯»æ‰¾æ‰‹åŠ¿æŒ‡ä»¤...";
                }
            });

            const cam = new Camera(document.getElementById('v'), {
                onFrame: async () => { await hands.send({image: document.getElementById('v')}); },
                width: 320, height: 240
            });

            cam.start().catch(e => {
                document.getElementById('status').innerText = "âš ï¸ ç‚¹å‡»å±å¹•å¼€å¯ä½“éªŒ";
                window.addEventListener('click', ()=>cam.start(), {once:true});
            });
        }

        resize();
        window.addEventListener('resize', resize);
        let loaded = 0;
        for(let i=1; i<=totalPhotos; i++) {
            const img = new Image(); img.crossOrigin = "anonymous"; img.src = `mj/${i}.jpg`;
            img.onload = () => {
                photos.push({img, seedX:(Math.random()-0.5)*w*1.8, seedY:(Math.random()-0.5)*h*1.8, seedZ:Math.random()*600});
                if(++loaded === totalPhotos) { initAI(); animate(); }
            };
        }
    </script>
</body>
</html>
