<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>2026 Star & Cake</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@1,400&family=Syncopate:wght@700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; }
        html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background: #000; position: fixed; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }
        #ui { 
            position: absolute; top: 30px; left: 20px; z-index: 10; 
            pointer-events: none; transition: opacity 0.5s ease;
        }
        .year { 
            font-family: 'Syncopate', sans-serif;
            font-size: 14vw; font-weight: 700; color: rgba(255,215,0,0.3); 
            margin: 0; line-height: 0.8;
        }
        .subtitle {
            font-family: 'Playfair Display', serif; font-style: italic;
            font-size: 5vw; color: rgba(255, 255, 255, 0.4); margin-top: 5px;
        }
        #status { 
            margin-top: 15px; color: #fff; font-size: 10px; 
            padding: 5px 10px; background: rgba(255,215,0,0.2); 
            display: inline-block; border-radius: 20px;
        }
        video { display: none; }
        body.gathering #ui { opacity: 0; }
    </style>
</head>
<body>
    <div id="ui">
        <h1 class="year">2026</h1>
        <div class="subtitle">Á•ù‰Ω†ÂºÄÂøÉ</div>
        <div id="status">ÁÇπÂáªÂ±èÂπïÂºÄÂêØ</div>
    </div>
    <canvas id="c"></canvas>
    <video id="v" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const totalPhotos = 10;
        let w, h, dpr, photos = [], bgStars = [], rockets = [], explosions = [];
        let isHandVisible = false, isPinching = false, handX = 0;
        let gatherLerp = 0, time = 0;

        // ËõãÁ≥ïÂùêÊ†á (3D)
        const cakeCoords = [];
        for(let i=0; i<5; i++) { // Â∫ïÂ±Ç
            let a = (i/5)*Math.PI*2; 
            cakeCoords.push({x: Math.cos(a)*180, y: 150, z: Math.sin(a)*180});
        }
        for(let i=0; i<3; i++) { // ‰∏≠Â±Ç
            let a = (i/3)*Math.PI*2 + 0.5;
            cakeCoords.push({x: Math.cos(a)*100, y: 0, z: Math.sin(a)*100});
        }
        for(let i=0; i<2; i++) { // È°∂Â±Ç
            let a = (i/2)*Math.PI*2;
            cakeCoords.push({x: Math.cos(a)*40, y: -120, z: Math.sin(a)*40});
        }

        function resize() {
            w = window.innerWidth; h = window.innerHeight;
            dpr = Math.min(window.devicePixelRatio || 1, 2);
            canvas.width = w * dpr; canvas.height = h * dpr;
            ctx.scale(dpr, dpr);
            // ÂàùÂßãÂåñËÉåÊôØÁπÅÊòüÁ≤íÂ≠ê
            bgStars = [];
            for(let i=0; i<150; i++) {
                bgStars.push({
                    x: (Math.random()-0.5)*w*2, y: (Math.random()-0.5)*h*2, z: Math.random()*1000,
                    size: Math.random()*3, hue: Math.random()*360
                });
            }
        }

        function project(x, y, z) {
            const fov = 600;
            const s = fov / (fov + z);
            return { x: x * s + w/2, y: y * s + h/2, scale: s };
        }

        // ÁÉüËä±ÈÄªËæë
        class Explosion {
            constructor(x, y, hue) {
                this.p = [];
                for(let i=0; i<40; i++) {
                    let a = Math.random()*Math.PI*2, spd = Math.random()*5;
                    this.p.push({x, y, vx: Math.cos(a)*spd, vy: Math.sin(a)*spd, alpha: 1});
                }
                this.hue = hue;
            }
            update() {
                this.p.forEach(part => {
                    part.x += part.vx; part.y += part.vy; part.vy += 0.1; part.alpha -= 0.02;
                });
                this.p = this.p.filter(part => part.alpha > 0);
            }
            draw() {
                this.p.forEach(part => {
                    ctx.fillStyle = `hsla(${this.hue}, 80%, 60%, ${part.alpha})`;
                    ctx.beginPath(); ctx.arc(part.x, part.y, 1.5, 0, Math.PI*2); ctx.fill();
                });
            }
        }

        function animate() {
            time += 0.015;
            ctx.fillStyle = 'rgba(0, 0, 5, 0.3)';
            ctx.fillRect(0, 0, w, h);

            // 1. ËÉåÊôØÁπÅÊòüÊºÇÊµÆ
            bgStars.forEach(s => {
                s.z -= 2; if(s.z < 0) s.z = 1000;
                let p = project(s.x, s.y, s.z);
                ctx.fillStyle = `hsla(${s.hue}, 70%, 80%, ${0.5 * (1-s.z/1000)})`;
                ctx.beginPath(); ctx.arc(p.x, p.y, s.size * p.scale, 0, Math.PI*2); ctx.fill();
            });

            // 2. ÁÉüËä±
            if (Math.random() < (isPinching ? 0.08 : 0.02)) {
                explosions.push(new Explosion(Math.random()*w, Math.random()*h*0.6, Math.random()*360));
            }
            explosions.forEach(e => { e.update(); e.draw(); });
            explosions = explosions.filter(e => e.p.length > 0);

            // 3. ÁÖßÁâáÂ§ÑÁêÜ
            if (photos.length > 0) {
                let targetGather = isPinching ? 1 : 0;
                gatherLerp += (targetGather - gatherLerp) * 0.1;

                if(gatherLerp > 0.1) document.body.classList.add('gathering');
                else document.body.classList.remove('gathering');

                let renderQueue = [];
                photos.forEach((pData, i) => {
                    // Êï£ÂºÄ‰ΩçÁΩÆÔºöÈöèÊú∫Âú® 3D Á©∫Èó¥ÊºÇÊµÆ
                    let sx = pData.seedX + Math.sin(time + i)*50;
                    let sy = pData.seedY + Math.cos(time + i)*50;
                    let sz = pData.seedZ + Math.sin(time*0.5 + i)*100;

                    // ËõãÁ≥ï‰ΩçÁΩÆÔºöÊóãËΩ¨
                    let target = cakeCoords[i];
                    let rot = time * 0.8;
                    let tx = target.x * Math.cos(rot) - target.z * Math.sin(rot);
                    let tz = target.x * Math.sin(rot) + target.z * Math.cos(rot);
                    let ty = target.y;

                    // ÊèíÂÄº
                    let x = sx + (tx - sx) * gatherLerp;
                    let y = sy + (ty - sy) * gatherLerp;
                    let z = sz + (tz - sz) * gatherLerp;

                    let p = project(x, y, z);
                    let scale = p.scale * (gatherLerp > 0.5 ? 0.25 : 0.35);
                    
                    renderQueue.push({
                        img: pData.img, x: p.x, y: p.y, z: z,
                        s: scale, alpha: gatherLerp > 0.5 ? 1 : 0.6
                    });
                });

                renderQueue.sort((a,b) => b.z - a.z);
                renderQueue.forEach(item => {
                    ctx.save();
                    ctx.globalAlpha = item.alpha;
                    ctx.translate(item.x, item.y);
                    let iw = item.img.width * item.s, ih = item.img.height * item.s;
                    ctx.drawImage(item.img, -iw/2, -ih/2, iw, ih);
                    if(gatherLerp > 0.8) {
                        ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2;
                        ctx.strokeRect(-iw/2, -ih/2, iw, ih);
                    }
                    ctx.restore();
                });
            }
            requestAnimationFrame(animate);
        }

        async function initAI() {
            const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5});
            hands.onResults(res => {
                if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                    isHandVisible = true;
                    const lm = res.multiHandLandmarks[0];
                    isPinching = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y) < 0.05;
                    document.getElementById('status').innerText = isPinching ? "üéÇ ÁîüÊó•Âø´‰πêÔºÅ" : "üëã ÊçèÂêàÊâãÊåáÊ±áËÅöËõãÁ≥ï";
                } else {
                    isHandVisible = false; isPinching = false;
                    document.getElementById('status').innerText = "üîç ÂØªÊâæÊâãÊéå...";
                }
            });
            const cam = new Camera(document.getElementById('v'), {
                onFrame: async () => { await hands.send({image: document.getElementById('v')}); },
                width: 320, height: 240
            });
            window.addEventListener('touchstart', () => { cam.start(); }, {once: true});
        }

        resize();
        window.addEventListener('resize', resize);
        let loaded = 0;
        for(let i=1; i<=totalPhotos; i++) {
            const img = new Image(); img.crossOrigin = "anonymous";
            img.src = `mj/${i}.jpg`;
            img.onload = () => {
                photos.push({
                    img, 
                    // ÂàùÂßãÊï£ÂºÄÁßçÂ≠êÂùêÊ†á
                    seedX: (Math.random()-0.5)*w*1.5,
                    seedY: (Math.random()-0.5)*h*1.5,
                    seedZ: Math.random()*500
                });
                if(++loaded === totalPhotos) { initAI(); animate(); }
            };
        }
    </script>
</body>
</html>
