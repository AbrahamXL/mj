<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Best wishes - è‰ºæœ¯äº¤äº’è£…ç½®</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@1,600&family=Montserrat:wght@300&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Montserrat', sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; background: radial-gradient(circle at center, #0a0a1a 0%, #000 100%); }
        
        /* --- è‰ºæœ¯æ–‡å­—é‡æ–°è®¾è®¡ --- */
        #title-container {
            position: absolute; top: 15%; width: 100%; text-align: center;
            pointer-events: none; z-index: 10;
        }

        #main-title {
            font-family: 'Playfair Display', serif;
            font-size: 5.5rem;
            font-style: italic;
            margin: 0;
            line-height: 1;
            /* è±ªåé‡‘è‰²æµå…‰ */
            background: linear-gradient(75deg, 
                rgba(255,215,0,1) 0%, 
                rgba(255,255,255,1) 45%, 
                rgba(255,215,0,1) 55%, 
                rgba(255,215,0,1) 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shine 4s linear infinite;
            filter: drop-shadow(0 0 20px rgba(255,215,0,0.35));
        }

        @keyframes shine {
            to { background-position: 200% center; }
        }

        /* --- äº¤äº’è¯´æ˜æ¡ --- */
        #info-instructions {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.7); background: rgba(255,255,255,0.05); 
            padding: 10px 40px; border-radius: 50px;
            border: 1px solid rgba(255,215,0,0.2); backdrop-filter: blur(20px);
            font-size: 0.85rem; z-index: 10; letter-spacing: 2px;
        }
        #video-input { display: none; }
    </style>
</head>
<body>
    <div id="title-container">
        <h1 id="main-title">Best wishes</h1>
    </div>
    
    <div id="container">
        <div id="info-instructions">æ­£åœ¨å”¤é†’å†¬æ—¥é­”æ³•...</div>
        <video id="video-input" playsinline></video>
    </div>

    <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particleSystem, mainGroup, snowSystem;
        let treePos = [], starPos = [], currentPos = [], snowData = [];
        let currentColors = [], targetColors = [];
        let isChangingColor = false, colorStartTime = 0;
        let morphFactor = 0, targetMorph = 0, targetRotX = 0, targetRotY = 0, windForce = 0, lastColorChange = 0;

        const COUNT = 3500; 
        const SNOW_COUNT = 800;
        // å®šä¹‰è£…é¥°å“çš„èµ·å§‹ç´¢å¼•ï¼Œç”¨äºåç»­å˜è‰²é€»è¾‘
        const DECO_START_INDEX = COUNT - 600; 

        const colorThemes = [
            [0xffd700, 0xff0000, 0xffffff, 0xff0055], 
            [0x00f2ff, 0x0066ff, 0xaa00ff, 0xffffff], 
            [0xff00ff, 0x00ff88, 0xffd700, 0x00ccff], 
        ];
        let currentThemeIdx = 0;

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.3, 'rgba(255,230,150,0.9)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 45;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            const geo = new THREE.BufferGeometry();
            const posArr = new Float32Array(COUNT * 3);
            const colArr = new Float32Array(COUNT * 3);

            // å®šä¹‰è›‹ç³•çš„å±‚çº§å‚æ•° (åŠå¾„, é«˜åº¦, åŸºåº•Yåæ ‡)
            const tiers = [
                { r: 12, h: 5.5, y: -10 }, // åº•å±‚
                { r: 8.5, h: 5.5, y: -4.5 }, // ä¸­å±‚
                { r: 5,  h: 5.5, y: 1.0 }   // é¡¶å±‚
            ];

            for(let i=0; i<COUNT; i++) {
                let vTree = new THREE.Vector3();
                let pColor = new THREE.Color();

                // --- æ„å»ºè›‹ç³•å½¢çŠ¶ ---
                if (i < DECO_START_INDEX) {
                    // === è›‹ç³•ä¸»ä½“ (å¥¶æ²¹å’Œç³–éœœå±‚) ===
                    let tierIdx = 0;
                    // æ ¹æ®ç´¢å¼•åˆ†é…åˆ°ä¸åŒçš„å±‚
                    if (i > DECO_START_INDEX * 0.45) tierIdx = 1;
                    if (i > DECO_START_INDEX * 0.8) tierIdx = 2;

                    const t = tiers[tierIdx];
                    const angle = Math.random() * Math.PI * 2;
                    let r, y, colorHex;

                    // å†³å®šæ˜¯åšä¾§å£è¿˜æ˜¯åšé¡¶éƒ¨ç³–éœœå¹³é¢
                    if (Math.random() > 0.3) {
                        // ä¾§å£ (è›‹ç³•ä½“) - ç¨å¾®åŠ ä¸€ç‚¹éšæœºæŠ–åŠ¨è®©å®ƒçœ‹èµ·æ¥æ¾è½¯
                        r = t.r * (0.96 + Math.random() * 0.08);
                        y = t.y + Math.random() * t.h;
                        // åŸºç¡€å¥¶æ²¹è‰²ï¼Œå¸¦ä¸€ç‚¹ç‚¹å˜åŒ–
                        colorHex = (i % 3 === 0) ? 0xFFFDD0 : 0xFFF8E7; 
                    } else {
                        // é¡¶éƒ¨å¹³é¢ (ç™½è‰²ç³–éœœå±‚) - å‡åŒ€åˆ†å¸ƒåœ¨åœ†ç›˜ä¸Š
                        r = Math.sqrt(Math.random()) * t.r * 1.03; // ç¨å¾®æ¯”ä¾§å£å®½ä¸€ç‚¹ç‚¹
                        y = t.y + t.h + (Math.random()-0.5)*0.3;
                        colorHex = 0xFFFFFF; // çº¯ç™½ç³–éœœ
                    }
                    vTree.set(r * Math.cos(angle), y, r * Math.sin(angle));
                    pColor.setHex(colorHex);

                } else {
                    // === è£…é¥°å“ (ä½äºDECO_START_INDEXä¹‹å) ===
                    // éšæœºåˆ†å¸ƒåœ¨å„å±‚çš„è¾¹ç¼˜æˆ–è€…æœ€é¡¶å±‚çš„ä¸­å¿ƒ
                    const tierIdx = Math.floor(Math.random() * tiers.length);
                    const t = tiers[tierIdx];
                    const angle = Math.random() * Math.PI * 2;
                    let r, y;

                    // å¦‚æœåœ¨æœ€é¡¶å±‚ï¼Œæœ‰æ¦‚ç‡æ”¾åœ¨ä¸­é—´åšèœ¡çƒ›/é¡¶éƒ¨è£…é¥°
                    if (tierIdx === tiers.length - 1 && Math.random() > 0.6) {
                         r = Math.sqrt(Math.random()) * t.r * 0.6; // é è¿‘ä¸­å¿ƒ
                         y = t.y + t.h + Math.random() * 3 + 0.5; // ç¨å¾®é«˜ä¸€ç‚¹
                    } else {
                        // æ”¾åœ¨å„å±‚çš„è¾¹ç¼˜åšè£±èŠ±/ç³–ç è£…é¥°
                         r = t.r * (1.02 + Math.random()*0.1);
                         y = t.y + t.h + Math.random()*0.8;
                    }

                    vTree.set(r * Math.cos(angle), y, r * Math.sin(angle));
                    // è£…é¥°å“ä½¿ç”¨å½“å‰ä¸»é¢˜é¢œè‰²
                    pColor.setHex(colorThemes[0][i % 4]);
                }

                // ä¿æŒåŸæœ‰çš„ç‚¸å¼€/æ˜Ÿç©ºä½ç½®é€»è¾‘
                treePos.push(vTree);
                starPos.push(new THREE.Vector3().setFromSphericalCoords(25 + Math.random() * 30, Math.random() * Math.PI, Math.random() * Math.PI * 2));
                currentPos.push(vTree.clone());
                currentColors.push(pColor.clone());
                targetColors.push(pColor.clone());
                
                posArr[i*3] = vTree.x; posArr[i*3+1] = vTree.y; posArr[i*3+2] = vTree.z;
                colArr[i*3] = pColor.r; colArr[i*3+1] = pColor.g; colArr[i*3+2] = pColor.b;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
            particleSystem = new THREE.Points(geo, new THREE.PointsMaterial({
                size: 0.75, map: createStarTexture(), transparent: true, blending: THREE.AdditiveBlending, vertexColors: true, depthWrite: false
            }));
            mainGroup.add(particleSystem);

            // é›ªèŠ±ç³»ç»Ÿä¿æŒä¸å˜
            const snowGeo = new THREE.BufferGeometry();
            const snowPositions = new Float32Array(SNOW_COUNT * 3);
            for(let i=0; i<SNOW_COUNT; i++) {
                snowPositions[i*3] = (Math.random()-0.5)*100;
                snowPositions[i*3+1] = Math.random()*60 - 30;
                snowPositions[i*3+2] = (Math.random()-0.5)*100;
                snowData.push({ velY: -0.05 - Math.random()*0.1, velX: (Math.random()-0.5)*0.05 });
            }
            snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
            snowSystem = new THREE.Points(snowGeo, new THREE.PointsMaterial({
                size: 0.4, color: 0xffffff, transparent: true, opacity: 0.5, map: createStarTexture(), blending: THREE.AdditiveBlending, depthWrite: false
            }));
            scene.add(snowSystem);

            animate();
        }

        function handleThemeChange() {
            currentThemeIdx = (currentThemeIdx + 1) % colorThemes.length;
            const newTheme = colorThemes[currentThemeIdx];
            colorStartTime = Date.now();
            isChangingColor = true;
            
            // ä¿®æ”¹å˜è‰²é€»è¾‘ï¼šåªæ”¹å˜è›‹ç³•ä¸Šçš„è£…é¥°å“éƒ¨åˆ†
            for(let i=0; i<COUNT; i++) {
                if (i >= DECO_START_INDEX) {
                    targetColors[i].setHex(newTheme[i % newTheme.length]);
                }
            }
            lastColorChange = Date.now();
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = Date.now();
            
            morphFactor = THREE.MathUtils.lerp(morphFactor, targetMorph, 0.08); 
            mainGroup.rotation.y += 0.003;
            mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, targetRotY, 0.05);
            mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, targetRotX, 0.05);

            // å¢å¼ºç‰ˆæ–‡å­—è§†å·®
            const title = document.getElementById('title-container');
            title.style.transform = `translate(${targetRotY * 12}px, ${-targetRotX * 6}px)`;

            const posAttr = particleSystem.geometry.attributes.position;
            const colAttr = particleSystem.geometry.attributes.color;
            let cAlpha = Math.min((now - colorStartTime) / 1200, 1.0);

            for(let i=0; i<COUNT; i++) {
                currentPos[i].lerpVectors(treePos[i], starPos[i], morphFactor);
                posAttr.array[i*3] = currentPos[i].x;
                // è›‹ç³•ä¸éœ€è¦åƒæ ‘ä¸€æ ·æœ‰é‚£ç§ç‰¹å®šçš„å‘¼å¸æ‘†åŠ¨ï¼Œç¨å¾®å‡å¼±ä¸€ç‚¹
                posAttr.array[i*3+1] = currentPos[i].y + (i >= DECO_START_INDEX ? Math.sin(now*0.002+i)*0.05 : 0);
                posAttr.array[i*3+2] = currentPos[i].z;

                if (isChangingColor) {
                    const c = currentColors[i].clone().lerp(targetColors[i], cAlpha);
                    colAttr.array[i*3] = c.r; colAttr.array[i*3+1] = c.g; colAttr.array[i*3+2] = c.b;
                    if (cAlpha >= 1 && i === COUNT-1) isChangingColor = false;
                }
            }
            
            const sPos = snowSystem.geometry.attributes.position;
            windForce = THREE.MathUtils.lerp(windForce, targetRotY * 0.03, 0.05);
            for(let i=0; i<SNOW_COUNT; i++) {
                sPos.array[i*3+1] -= 0.08;
                sPos.array[i*3] += windForce;
                if(sPos.array[i*3+1] < -30) sPos.array[i*3+1] = 30;
                if(sPos.array[i*3] > 50) sPos.array[i*3] = -50;
                if(sPos.array[i*3] < -50) sPos.array[i*3] = 50;
            }

            posAttr.needsUpdate = true; colAttr.needsUpdate = true; sPos.needsUpdate = true;
            renderer.render(scene, camera);
        }

        async function startAI() {
            const info = document.getElementById('info-instructions');
            const hands = new Hands({ locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.75 });
            
            hands.onResults(res => {
                if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                    const h = res.multiHandLandmarks[0];
                    const wrist = h[0];
                    const fingers = [8, 12, 16, 20];
                    let extendedFingers = 0;

                    fingers.forEach(tipIdx => {
                        const distTip = Math.hypot(h[tipIdx].x - wrist.x, h[tipIdx].y - wrist.y);
                        const distMcp = Math.hypot(h[tipIdx-3].x - wrist.x, h[tipIdx-3].y - wrist.y);
                        if (distTip > distMcp * 1.2) extendedFingers++;
                    });

                    targetMorph = extendedFingers / 4; 

                    const distPinch = Math.hypot(h[4].x - h[8].x, h[4].y - h[8].y);
                    const palmSize = Math.hypot(h[0].x - h[5].x, h[0].y - h[5].y);
                    if (distPinch / palmSize < 0.4 && (Date.now() - lastColorChange > 2000)) handleThemeChange();

                    targetRotY = (0.5 - h[9].x) * 12; 
                    targetRotX = (h[9].y - 0.5) * 6;
                    
                    info.innerHTML = `ğŸ–ï¸ å¼ åˆæ§åˆ¶çˆ†å‘ (${extendedFingers}) | ğŸ‘Œ æåˆå˜æ¢è‰²å½©`;
                } else {
                    info.innerText = "âœ¨ è¯·å±•ç¤ºæ‚¨çš„æ‰‹æŒå¼€å¯é­”æ³•äº’åŠ¨";
                }
            });

            const cam = new Camera(document.getElementById('video-input'), {
                onFrame: async () => { await hands.send({ image: document.getElementById('video-input') }); },
                width: 640, height: 480
            });
            cam.start();
        }

        window.onload = () => { init(); startAI(); };
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
