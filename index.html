<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>2026å…ƒæ—¦å¿«ä¹ - æè‡´é‡‘è¿·æ˜Ÿæµ·ç‰ˆ</title>
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+XiaoWei&family=Playfair+Display:ital,wght@1,900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Montserrat', sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; background: #000; }
        
        /* æ–‡å­—å®¹å™¨ - æè‡´æ¸…æ™°åº¦å¤„ç† */
        #title-container {
            position: absolute; top: 10%; width: 100%; text-align: center; pointer-events: none; z-index: 1000;
        }

        #main-title {
            font-family: 'ZCOOL XiaoWei', serif;
            margin: 0; padding: 0 20px; line-height: 1.1; color: transparent;
            background-image: linear-gradient(135deg, #FFF 10%, #FFD700 40%, #E6C778 70%, #B8860B 100%);
            background-size: 200% auto; -webkit-background-clip: text; background-clip: text;
            /* é»‘è‰²æè¾¹ + é‡‘è‰²å‘å…‰ = ç»å¯¹æ¸…æ™° */
            filter: drop-shadow(0px 0px 1px rgba(0,0,0,1)) 
                    drop-shadow(0px 0px 12px rgba(255, 215, 0, 0.6));
            animation: textShimmer 4s linear infinite alternate;
        }

        #main-title .year { font-family: 'Playfair Display', serif; font-style: italic; font-weight: 900; font-size: 7.5rem; display: block; }
        #main-title .bless-1 { font-size: 4.2rem; display: block; letter-spacing: 0.2em; margin-top: -5px; font-weight: bold; }
        #main-title .bless-2 { font-size: 2.5rem; display: block; letter-spacing: 0.5em; margin-top: 15px; color: #FFD700; -webkit-text-fill-color: #FFD700; }

        @keyframes textShimmer { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }

        #info-instructions {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            color: #FFD700; background: rgba(0,0,0,0.8); padding: 12px 35px; border-radius: 50px; 
            border: 2px solid #FFD700; font-size: 0.9rem; z-index: 100; letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(255,215,0,0.4);
        }
        #video-input { display: none; }
    </style>
</head>
<body>
    <div id="title-container">
        <h1 id="main-title">
            <span class="year">2026</span>
            <span class="bless-1">å…ƒæ—¦å¿«ä¹</span>
            <span class="bless-2">å­¦ä¸šæœ‰æˆ</span>
        </h1>
    </div>

    <div id="container">
        <div id="info-instructions">æ­£åœ¨ä¸ºæ‚¨ç¼–ç»‡æµªæ¼«é‡‘æµ·...</div>
        <video id="video-input" playsinline></video>
    </div>

    <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particleSystem, mainGroup, imageGroup;
        let treePos = [], starPos = [], currentPos = [];
        let baseSizes = [];
        let morphFactor = 0, targetMorph = 0, targetRotX = 0, targetRotY = 0;

        const COUNT = 7000; 
        const IMG_COUNT = 10;

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(255,255,200,1)');
            grad.addColorStop(0.4, 'rgba(255,215,0,0.7)');
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 2000);
            camera.position.z = 70;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            // ç…§ç‰‡ç¯
            imageGroup = new THREE.Group();
            mainGroup.add(imageGroup);
            const loader = new THREE.TextureLoader();
            for(let i=1; i<=IMG_COUNT; i++) {
                const texture = loader.load(`./mj/${i}.jpg`);
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0, side: THREE.DoubleSide });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(10, 12.5), material);
                const angle = ((i-1) / IMG_COUNT) * Math.PI * 2;
                mesh.position.set(Math.cos(angle) * 35, -5, Math.sin(angle) * 35);
                mesh.lookAt(0, -5, 0); 
                imageGroup.add(mesh);
            }

            const geo = new THREE.BufferGeometry();
            const posArr = new Float32Array(COUNT * 3);
            const colArr = new Float32Array(COUNT * 3);
            const sizeArr = new Float32Array(COUNT);
            baseSizes = new Float32Array(COUNT);
            
            const goldColor = new THREE.Color(0xFFD700);

            for(let i=0; i<COUNT; i++) {
                // 1. æ±‡èšå½¢æ€ (æ ¸å¿ƒå…‰çƒ)
                const rTree = 10 * Math.cbrt(Math.random());
                const vTree = new THREE.Vector3().setFromSphericalCoords(rTree, Math.acos(2*Math.random()-1), Math.random()*Math.PI*2);
                
                // 2. æ•£å¼€å½¢æ€ (æµªæ¼«æ˜Ÿæµ·å¹•å¢™)
                // è¿™æ¬¡æˆ‘ä»¬å°†æ˜Ÿæ˜Ÿå¯†é›†åˆ†å¸ƒåœ¨ç…§ç‰‡åæ–¹ï¼Œå½¢æˆä¸€å±‚â€œé‡‘è‰²çš„å¢™â€
                const vStar = new THREE.Vector3();
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                // æ•£å¼€ååŠå¾„å¾ˆå¤§ï¼Œå½¢æˆä¸€ä¸ªåŒ…å›´åœˆ
                const rStar = 120 + Math.random() * 50; 
                vStar.setFromSphericalCoords(rStar, phi, theta);

                treePos.push(vTree);
                starPos.push(vStar);
                currentPos.push(vTree.clone());
                
                const s = 0.5 + Math.random() * 1.5;
                baseSizes[i] = s;
                posArr[i*3] = vTree.x; posArr[i*3+1] = vTree.y; posArr[i*3+2] = vTree.z;
                colArr[i*3] = goldColor.r; colArr[i*3+1] = goldColor.g; colArr[i*3+2] = goldColor.b;
                sizeArr[i] = s;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(sizeArr, 1));

            particleSystem = new THREE.Points(geo, new THREE.PointsMaterial({ 
                size: 1.0, map: createStarTexture(), transparent: true, blending: THREE.AdditiveBlending, 
                vertexColors: true, depthWrite: false, sizeAttenuation: true 
            }));
            mainGroup.add(particleSystem);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            const now = Date.now();
            morphFactor = THREE.MathUtils.lerp(morphFactor, targetMorph, 0.1);
            
            mainGroup.rotation.y += 0.003;
            mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, targetRotY + mainGroup.rotation.y, 0.1);
            mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, targetRotX, 0.1);

            imageGroup.children.forEach((mesh) => {
                // morphFactor > 0.3 å¼€å§‹æ˜¾ç°å›¾ç‰‡
                mesh.material.opacity = THREE.MathUtils.lerp(0, 1, (morphFactor - 0.2) * 4);
                mesh.scale.setScalar(THREE.MathUtils.clamp(morphFactor * 1.2, 0.01, 1));
            });

            const posAttr = particleSystem.geometry.attributes.position;
            const sizeAttr = particleSystem.geometry.attributes.size;

            for(let i=0; i<COUNT; i++) {
                currentPos[i].lerpVectors(treePos[i], starPos[i], morphFactor);
                
                // æ•£å¼€åçš„â€œæµªæ¼«é—ªçƒâ€é€»è¾‘
                // æ•£å¼€åæ˜Ÿæ˜Ÿå˜å¤§ï¼Œé—ªçƒé¢‘ç‡é™ä½ï¼Œåˆ¶é€ ç¼“æ…¢çš„å‘¼å¸æ„Ÿ
                let twinkle = 0.7 + Math.sin(now * 0.001 + i) * 0.3;
                
                // --- æ•£å¼€å°ºå¯¸è†¨èƒ€ (Scatter Expansion) ---
                // å½“æ‰‹å¼ å¼€æ—¶ (morphFactor -> 1)ï¼ŒåŸºç¡€å°ºå¯¸å¤§å¹…åº¦ç¿»å€ï¼Œå½¢æˆæ˜æ˜¾çš„èƒŒæ™¯å…‰æ–‘
                let scatterScale = 1 + (morphFactor * 10.0); 

                posAttr.array[i*3] = currentPos[i].x;
                posAttr.array[i*3+1] = currentPos[i].y;
                posAttr.array[i*3+2] = currentPos[i].z;

                sizeAttr.array[i] = baseSizes[i] * scatterScale * twinkle;
            }
            posAttr.needsUpdate = true;
            sizeAttr.needsUpdate = true;
            renderer.render(scene, camera);
        }

        async function startAI() {
            const info = document.getElementById('info-instructions');
            try {
                const hands = new Hands({ locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}` });
                hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
                
                hands.onResults(res => {
                    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                        const h = res.multiHandLandmarks[0];
                        const fingers = [8, 12, 16, 20];
                        let openCount = 0;
                        fingers.forEach(tip => { if (h[tip].y < h[tip-2].y) openCount++; });
                        targetMorph = openCount / 4;
                        targetRotY = (0.5 - h[9].x) * 4;
                        targetRotX = (h[9].y - 0.5) * 2;
                        info.innerHTML = morphFactor > 0.5 ? "âœ¨ æ²‰æµ¸äºæµªæ¼«æ˜Ÿæµ·" : "âœŠ æ¡æ‹³æ±‡èšï¼ŒğŸ–ï¸ å¼ å¼€å±•ç¤º 2026 ç’€ç’¨èƒŒæ™¯";
                    } else {
                        info.innerText = "ğŸ‘‹ æŒ¥æŒ¥æ‰‹ï¼Œå¼€å¯ 2026 è¾‰ç…Œç¯‡ç« ";
                    }
                });

                const cam = new Camera(document.getElementById('video-input'), {
                    onFrame: async () => { await hands.send({ image: document.getElementById('video-input') }); },
                    width: 640, height: 480
                });
                cam.start();
            } catch(e) {
                info.innerText = "âš ï¸ æ‘„åƒå¤´å·²é™é»˜è¿è¡Œ";
            }
        }

        window.onload = () => { init(); startAI(); };
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
