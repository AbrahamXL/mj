<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2026ÂÖÉÊó¶Âø´‰πê - ÊûÅÂÖâÊµÅÈáëÁâà</title>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=ZCOOL+XiaoWei&family=Playfair+Display:ital,wght@1,900&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; touch-action: none; }
        #container { position: relative; width: 100vw; height: 100vh; background: radial-gradient(circle at center, #1a0a2e 0%, #000 100%); }
        
        #title-container {
            position: absolute; top: 8%; width: 100%; text-align: center; pointer-events: none; z-index: 100;
        }

        #main-title {
            font-weight: normal; margin: 0; padding: 0 10px;
            color: transparent;
            background-image: linear-gradient(135deg, #FFF 0%, #FFD700 30%, #E6C778 60%, #8A2BE2 100%);
            background-size: 200% auto;
            -webkit-background-clip: text;
            background-clip: text;
            filter: drop-shadow(0px 0px 5px rgba(0,0,0,0.8)) drop-shadow(0px 0px 15px rgba(138, 43, 226, 0.4));
            animation: artisticShimmer 5s linear infinite alternate;
        }

        #main-title .year {
            font-family: 'Playfair Display', serif; font-style: italic; font-weight: 900;
            font-size: clamp(4rem, 15vw, 7rem); display: block; line-height: 0.9;
        }

        #main-title .bless-1 { 
            font-family: 'Ma Shan Zheng', cursive; 
            font-size: clamp(3rem, 12vw, 5.5rem); 
            display: block; 
            margin-top: 5px;
            line-height: 1.2;
            padding-bottom: 25px; /* ÂΩªÂ∫ï‰øÆÂ§ç‚ÄúÊó¶‚ÄùÂ≠óÂàáËæπ */
        }
        
        #main-title .bless-2 { 
            font-family: 'ZCOOL XiaoWei', serif;
            font-size: clamp(1rem, 4.5vw, 2rem); display: block; letter-spacing: 0.3em; margin-top: -5px;
        }

        @keyframes artisticShimmer { 0% { background-position: 0% 50%; } 100% { background-position: 100% 50%; } }

        #info-instructions {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.7); background: rgba(0,0,0,0.4); 
            padding: 8px 25px; border-radius: 50px; border: 1px solid rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(10px); font-size: 0.7rem; z-index: 100; white-space: nowrap;
        }
        #video-input { display: none; }
    </style>
</head>
<body>
    <div id="title-container">
        <h1 id="main-title">
            <span class="year">2026</span>
            <span class="bless-1">ÂÖÉÊó¶Âø´‰πê</span>
            <span class="bless-2">Â§©Â§©ÂºÄÂøÉÔºåÂ≠¶‰∏öÊúâÊàê</span>
        </h1>
    </div>

    <div id="container">
        <div id="info-instructions">Ê≠£Âú®Âè¨Âî§Êòü‰∫ë...</div>
        <video id="video-input" playsinline></video>
    </div>

    <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        let scene, camera, renderer, particleSystem, mainGroup, imageGroup;
        let galaxyPoints = [], starPos = [], currentPos = [];
        let morphFactor = 0, targetMorph = 0, targetRotX = 0, targetRotY = 0;

        const COUNT = isMobile ? 3000 : 7000;
        const IMG_COUNT = 10;

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(255,220,100,0.8)');
            grad.addColorStop(0.5, 'rgba(138,43,226,0.3)');
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 1000);
            camera.position.z = 80;

            renderer = new THREE.WebGLRenderer({ antialias: !isMobile, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(isMobile ? 1 : Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            // ÂõæÁâáÂõæÂ±Ç
            imageGroup = new THREE.Group();
            mainGroup.add(imageGroup);
            const loader = new THREE.TextureLoader();
            for(let i=1; i<=IMG_COUNT; i++) {
                const texture = loader.load(`./mj/${i}.jpg`, undefined, undefined, ()=>{});
                const mesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(9, 11),
                    new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0, side: THREE.DoubleSide })
                );
                const angle = ((i-1) / IMG_COUNT) * Math.PI * 2;
                mesh.position.set(Math.cos(angle) * 35, -5, Math.sin(angle) * 35);
                mesh.lookAt(0, -5, 0); 
                imageGroup.add(mesh);
            }

            const geo = new THREE.BufferGeometry();
            const posArr = new Float32Array(COUNT * 3);
            const colArr = new Float32Array(COUNT * 3);
            
            const colors = [new THREE.Color(0xffffff), new THREE.Color(0xffd700), new THREE.Color(0x8a2be2)];

            for(let i=0; i<COUNT; i++) {
                let v = new THREE.Vector3();
                let c = new THREE.Color();
                
                // Ëû∫ÊóãÊòü‰∫ëÁÆóÊ≥ï
                const branch = i % 3; // ‰∏âÊù°ÊóãËáÇ
                const distance = Math.random() * 25;
                const angle = distance * 0.4 + (branch * (Math.PI * 2 / 3));
                const randomOffset = (Math.pow(Math.random(), 3) * (Math.random() < 0.5 ? 1 : -1)) * 3;
                
                v.x = Math.cos(angle) * distance + randomOffset;
                v.y = (Math.random() - 0.5) * (distance * 0.2);
                v.z = Math.sin(angle) * distance + randomOffset;

                // Ê†∏ÂøÉÂå∫ÂüüÂä†ÂØÜ
                if(i < COUNT * 0.2) {
                    const r = Math.random() * 5;
                    v.setFromSphericalCoords(r, Math.random()*Math.PI, Math.random()*Math.PI*2);
                }

                galaxyPoints.push(v.clone());
                starPos.push(new THREE.Vector3().setFromSphericalCoords(60 + Math.random()*30, Math.random()*Math.PI, Math.random()*Math.PI*2));
                currentPos.push(v.clone());
                
                c.lerpColors(colors[1], colors[2], distance / 25);
                if(Math.random() > 0.9) c.copy(colors[0]); // ÈöèÊú∫‰∫ÆÊòü

                posArr[i*3] = v.x; posArr[i*3+1] = v.y; posArr[i*3+2] = v.z;
                colArr[i*3] = c.r; colArr[i*3+1] = c.g; colArr[i*3+2] = c.b;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colArr, 3));

            particleSystem = new THREE.Points(geo, new THREE.PointsMaterial({ 
                size: isMobile ? 1.0 : 0.7, map: createStarTexture(), transparent: true, 
                blending: THREE.AdditiveBlending, vertexColors: true, depthWrite: false 
            }));
            mainGroup.add(particleSystem);
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            morphFactor = THREE.MathUtils.lerp(morphFactor, targetMorph, 0.08);
            
            // Âü∫Á°ÄÊóãËΩ¨
            mainGroup.rotation.y += 0.002;
            // ÊâãÂäø‰∫íÂä®ÊóãËΩ¨
            mainGroup.rotation.y += targetRotY * 0.05;
            mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, targetRotX, 0.05);

            if(imageGroup) {
                imageGroup.children.forEach((mesh, i) => {
                    mesh.material.opacity = THREE.MathUtils.clamp((morphFactor - 0.2) * 2, 0, 0.8);
                    const hover = Math.sin(time + i) * 1;
                    mesh.position.y = -5 + hover;
                });
            }

            const posAttr = particleSystem.geometry.attributes.position;
            for(let i=0; i<COUNT; i++) {
                const target = new THREE.Vector3();
                target.lerpVectors(galaxyPoints[i], starPos[i], morphFactor);
                
                // Ê∑ªÂä†Âä®ÊÄÅÊâ≠Âä®ÊÑü
                const drift = Math.sin(time * 0.5 + i * 0.1) * 0.2;
                posAttr.array[i*3] = target.x + drift;
                posAttr.array[i*3+1] = target.y + drift;
                posAttr.array[i*3+2] = target.z + drift;
            }
            posAttr.needsUpdate = true;
            renderer.render(scene, camera);
        }

        async function startAI() {
            const info = document.getElementById('info-instructions');
            try {
                const hands = new Hands({ locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}` });
                hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.6 });
                hands.onResults(res => {
                    if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                        const h = res.multiHandLandmarks[0];
                        const fingers = [8, 12, 16, 20];
                        let openCount = 0;
                        fingers.forEach(tip => { if (h[tip].y < h[tip-2].y) openCount++; });
                        targetMorph = openCount / 4;
                        targetRotY = (0.5 - h[9].x);
                        targetRotX = (h[9].y - 0.5);
                        info.innerHTML = "‚ú® Êòü‰∫ëËÉΩÈáèÂ∑≤ËøûÊé• | ÁßªÂä®ÊâãÊéå";
                    } else {
                        targetMorph = 0;
                        info.innerText = "üëã Êå•Êå•ÊâãÔºåÂºÄÂêØ 2026 ËæâÁÖåÁØáÁ´†";
                    }
                });

                const cam = new Camera(document.getElementById('video-input'), {
                    onFrame: async () => { await hands.send({ image: document.getElementById('video-input') }); },
                    width: 320, height: 240
                });
                cam.start();
            } catch(e) { info.innerText = "ËØ∑ÊéàÊùÉÊëÑÂÉèÂ§¥‰ª•Ëé∑ÂæóÊúÄ‰Ω≥‰ΩìÈ™å"; }
        }

        window.onload = () => { init(); startAI(); };
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
