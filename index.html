<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>2026 Particle Treasure</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@1,400&family=Syncopate:wght@700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; }
        html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background: #000; position: fixed; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }
        #ui { 
            position: absolute; top: 30px; left: 20px; z-index: 10; 
            pointer-events: none; transition: opacity 0.5s ease;
        }
        .year { 
            font-family: 'Syncopate', sans-serif;
            font-size: 14vw; font-weight: 700; color: rgba(255,215,0,0.3); 
            margin: 0; line-height: 0.8;
        }
        .subtitle {
            font-family: 'Playfair Display', serif; font-style: italic;
            font-size: 5vw; color: rgba(255, 255, 255, 0.4); margin-top: 5px;
        }
        #status { 
            margin-top: 15px; color: #fff; font-size: 10px; 
            padding: 5px 10px; background: rgba(255,215,0,0.2); 
            display: inline-block; border-radius: 20px;
        }
        video { display: none; }
        /* æ±‡èšæ—¶UIæ·¡å‡º */
        body.gathering #ui { opacity: 0.3; }
    </style>
</head>
<body>
    <div id="ui">
        <h1 class="year">2026</h1>
        <div class="subtitle">è—åœ¨æ˜Ÿè¾°é‡Œçš„ç¥ç¦</div>
        <div id="status">ç³»ç»Ÿå‡†å¤‡ä¸­...</div>
    </div>
    <canvas id="c"></canvas>
    <video id="v" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        const totalPhotos = 10;
        let w, h, dpr;
        // å¢åŠ  cakeParticles æ•°ç»„ç”¨äºç»„æˆè›‹ç³•ä¸»ä½“
        let photos = [], bgStars = [], explosions = [], cakeParticles = [];
        let isHandVisible = false, isPinching = false;
        let gatherLerp = 0, time = 0;

        // å®šä¹‰è›‹ç³•ç»“æ„çš„éª¨æ¶ç‚¹
        const cakeStructure = [];
        for(let i=0; i<5; i++) { let a=(i/5)*Math.PI*2; cakeStructure.push({x:Math.cos(a)*180, y:150, z:Math.sin(a)*180}); }
        for(let i=0; i<3; i++) { let a=(i/3)*Math.PI*2+0.5; cakeStructure.push({x:Math.cos(a)*100, y:0, z:Math.sin(a)*100}); }
        for(let i=0; i<2; i++) { let a=(i/2)*Math.PI*2; cakeStructure.push({x:Math.cos(a)*40, y:-120, z:Math.sin(a)*40}); }

        function resize() {
            w = window.innerWidth; h = window.innerHeight;
            dpr = Math.min(window.devicePixelRatio || 1, 2);
            canvas.width = w * dpr; canvas.height = h * dpr;
            ctx.scale(dpr, dpr);
            initParticles();
        }

        function initParticles() {
            bgStars = []; cakeParticles = [];
            // èƒŒæ™¯æ˜Ÿè¾°
            for(let i=0; i<100; i++) {
                bgStars.push({x:(Math.random()-0.5)*w*2, y:(Math.random()-0.5)*h*2, z:Math.random()*1000, size:Math.random()*2, hue:Math.random()*360});
            }
            // æ ¸å¿ƒï¼šåˆ›å»ºç»„æˆè›‹ç³•çš„å¯†é›†ç²’å­ç¾¤ (800ä¸ª)
            for(let i=0; i<800; i++) {
                // éšæœºé€‰æ‹©ä¸€ä¸ªè›‹ç³•éª¨æ¶ç‚¹ä½œä¸ºç›®æ ‡åŸºå‡†
                let targetBase = cakeStructure[Math.floor(Math.random() * cakeStructure.length)];
                cakeParticles.push({
                    // æ•£å¼€æ—¶çš„éšæœºä½ç½®
                    scatterX: (Math.random()-0.5)*w*1.5,
                    scatterY: (Math.random()-0.5)*h*1.5,
                    scatterZ: Math.random()*800,
                    // æ±‡èšæ—¶çš„ç›®æ ‡ä½ç½® (åœ¨éª¨æ¶ç‚¹é™„è¿‘éšæœºæŠ–åŠ¨ï¼Œå½¢æˆä½“ç§¯æ„Ÿ)
                    targetX: targetBase.x + (Math.random()-0.5)*60,
                    targetY: targetBase.y + (Math.random()-0.5)*40,
                    targetZ: targetBase.z + (Math.random()-0.5)*60,
                    // ç²’å­å±æ€§ (é‡‘è‰²/æš–è‰²è°ƒ)
                    hue: 40 + Math.random() * 20,
                    size: 1 + Math.random() * 2.5,
                    speedOffset: Math.random()
                });
            }
        }

        function project(x, y, z) {
            const fov = 600; const s = fov / (fov + z);
            return { x: x * s + w/2, y: y * s + h/2, scale: s };
        }

        class Explosion {
            constructor(x, y, hue) {
                this.p = [];
                for(let i=0; i<30; i++) {
                    let a=Math.random()*Math.PI*2, spd=Math.random()*6;
                    this.p.push({x, y, vx:Math.cos(a)*spd, vy:Math.sin(a)*spd, alpha:1});
                } this.hue = hue;
            }
            update() { this.p.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.vy+=0.1;p.alpha-=0.03;}); this.p=this.p.filter(p=>p.alpha>0); }
            draw() { this.p.forEach(p=>{ctx.fillStyle=`hsla(${this.hue},80%,60%,${p.alpha})`;ctx.beginPath();ctx.arc(p.x,p.y,2,0,Math.PI*2);ctx.fill();}); }
        }

        function animate() {
            time += 0.015;
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = 'rgba(0, 0, 8, 0.25)'; // æ·±è‰²èƒŒæ™¯
            ctx.fillRect(0, 0, w, h);

            // æ›´æ–°æ±‡èšè¿›åº¦
            let targetGather = isPinching ? 1 : 0;
            gatherLerp += (targetGather - gatherLerp) * 0.1;
            if(gatherLerp > 0.1) document.body.classList.add('gathering');
            else document.body.classList.remove('gathering');

            // æ—‹è½¬è§’åº¦
            let rot = time * 0.5;

            ctx.globalCompositeOperation = 'lighter'; // å åŠ å‘å…‰æ¨¡å¼

            // 1. ç»˜åˆ¶èƒŒæ™¯æ˜Ÿè¾°
            bgStars.forEach(s => {
                s.z-=1.5; if(s.z<0) s.z=1000;
                let p=project(s.x, s.y, s.z);
                ctx.fillStyle=`hsla(${s.hue},70%,80%,${0.4*(1-s.z/1000)})`;
                ctx.beginPath();ctx.arc(p.x,p.y,s.size*p.scale,0,Math.PI*2);ctx.fill();
            });

            // 2. æ ¸å¿ƒï¼šç»˜åˆ¶ç»„æˆè›‹ç³•çš„ç²’å­ç¾¤
            cakeParticles.forEach(cp => {
                // è®¡ç®—ç›®æ ‡ä½ç½®çš„æ—‹è½¬
                let tx = cp.targetX*Math.cos(rot) - cp.targetZ*Math.sin(rot);
                let tz = cp.targetX*Math.sin(rot) + cp.targetZ*Math.cos(rot);
                let ty = cp.targetY;

                // æ’å€¼è®¡ç®—å½“å‰ä½ç½®
                let x = cp.scatterX + (tx - cp.scatterX) * gatherLerp;
                let y = cp.scatterY + (ty - cp.scatterY) * gatherLerp;
                let z = cp.scatterZ + (tz - cp.scatterZ) * gatherLerp;

                let p = project(x, y, z);
                // æ±‡èšæ—¶æ›´äº®ï¼Œæ•£å¼€æ—¶å˜æš—
                let alpha = 0.3 + gatherLerp * 0.7;
                // å¢åŠ ä¸€ç‚¹é—ªçƒæ„Ÿ
                alpha *= (0.8 + Math.sin(time*2 + cp.speedOffset)*0.2);

                ctx.fillStyle = `hsla(${cp.hue}, 100%, 70%, ${alpha})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, cp.size * p.scale * (0.8 + gatherLerp*0.5), 0, Math.PI*2);
                ctx.fill();
            });

            // 3. ç»˜åˆ¶çƒŸèŠ± (ä»…åœ¨å¼ å¼€/æ•£å¼€ç¬é—´è§¦å‘)
            if (!isPinching && gatherLerp > 0.1 && Math.random() < 0.1) {
                explosions.push(new Explosion(w/2 + (Math.random()-0.5)*200, h/2 + (Math.random()-0.5)*200, Math.random()*360));
            }
            explosions.forEach(e => { e.update(); e.draw(); });
            explosions = explosions.filter(e => e.p.length > 0);

            // 4. ç»˜åˆ¶ç…§ç‰‡ (æ ¸å¿ƒä¿®æ”¹ï¼šåªåœ¨æ•£å¼€æ—¶æ˜¾ç¤º)
            ctx.globalCompositeOperation = 'source-over';
            if (photos.length > 0) {
                let renderQueue = [];
                photos.forEach((pData, i) => {
                    // æ•£å¼€ä½ç½®æ¼‚æµ®
                    let sx = pData.seedX + Math.sin(time + i)*30;
                    let sy = pData.seedY + Math.cos(time + i)*30;
                    let sz = pData.seedZ;
                    // è›‹ç³•éª¨æ¶ä½ç½® (ç”¨äºè®¡ç®—æ’å€¼ç»ˆç‚¹ï¼Œè™½ç„¶ç»ˆç‚¹ä¸å¯è§)
                    let target = cakeStructure[i];
                    let tx = target.x*Math.cos(rot) - target.z*Math.sin(rot);
                    let tz = target.x*Math.sin(rot) + target.z*Math.cos(rot);
                    
                    let x = sx + (tx - sx) * gatherLerp;
                    let y = sy + (target.y - sy) * gatherLerp;
                    let z = sz + (tz - sz) * gatherLerp;

                    let p = project(x, y, z);
                    
                    // --- å…³é”®ä¿®æ”¹ï¼šç…§ç‰‡å¯è§æ€§é€»è¾‘ ---
                    // gatherLerp è¶Šå¤§(è¶Šèšæ‹¢)ï¼Œå¯è§æ€§è¶Šä½ã€‚
                    // è®¾ç½®ä¸€ä¸ªé˜ˆå€¼ï¼Œè®©å®ƒä»¬åœ¨å¼€å§‹èšæ‹¢æ—¶å°±è¿…é€Ÿæ¶ˆå¤±
                    let visibility = Math.max(0, 1 - gatherLerp * 2.0);
                    
                    if (visibility > 0.01) {
                        renderQueue.push({img: pData.img, x: p.x, y: p.y, z: z, s: p.scale * 0.3, alpha: visibility});
                    }
                });

                renderQueue.sort((a,b) => b.z - a.z);
                renderQueue.forEach(item => {
                    ctx.save();
                    ctx.globalAlpha = item.alpha;
                    ctx.translate(item.x, item.y);
                    let iw = item.img.width * item.s, ih = item.img.height * item.s;
                    // ç»™ç…§ç‰‡åŠ ä¸ªæ·¡æ·¡çš„å…‰æ™•
                    ctx.shadowColor = 'rgba(255,215,0,0.5)'; ctx.shadowBlur = 10;
                    ctx.drawImage(item.img, -iw/2, -ih/2, iw, ih);
                    ctx.restore();
                });
            }
            requestAnimationFrame(animate);
        }

        async function initAI() {
            document.getElementById('status').innerText = "ğŸ“· å¯åŠ¨ç›¸æœº...";
            const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5});
            hands.onResults(res => {
                if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                    isHandVisible = true;
                    const lm = res.multiHandLandmarks[0];
                    // æåˆåˆ¤å®š
                    isPinching = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y) < 0.06;
                    document.getElementById('status').innerText = isPinching ? "âœ¨ å®è—å·²éšè—" : "ğŸ‰ å¼ å¼€æ‰‹æŒæ˜¾ç°ç…§ç‰‡";
                } else {
                    isHandVisible = false; isPinching = false; // æ‰‹æ¶ˆå¤±é»˜è®¤ä¸ºæ•£å¼€
                    document.getElementById('status').innerText = "ğŸ‘€ å¯»æ‰¾æ‰‹æŒ...";
                }
            });

            const cam = new Camera(document.getElementById('v'), {
                onFrame: async () => { await hands.send({image: document.getElementById('v')}); },
                width: 320, height: 240
            });

            cam.start().catch(e => {
                document.getElementById('status').innerText = "âš ï¸ éœ€è¦ç‚¹å‡»å±å¹•å¼€å¯";
                window.addEventListener('click', ()=>cam.start(), {once:true});
            });
        }

        resize();
        window.addEventListener('resize', resize);
        let loaded = 0;
        for(let i=1; i<=totalPhotos; i++) {
            const img = new Image(); img.crossOrigin = "anonymous"; img.src = `mj/${i}.jpg`;
            img.onload = () => {
                photos.push({img, seedX:(Math.random()-0.5)*w*1.8, seedY:(Math.random()-0.5)*h*1.8, seedZ:Math.random()*600});
                if(++loaded === totalPhotos) { initAI(); animate(); }
            };
        }
    </script>
</body>
</html>
