<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>2026å…ƒæ—¦å¿«ä¹ - äº¤äº’å½±åƒè£…ç½®</title>
    <link href="https://fonts.googleapis.com/css2?family=ZCOOL+XiaoWei&family=Playfair+Display:ital,wght@1,900&display=swap" rel="stylesheet">
    <style>
        /* èƒŒæ™¯ç¨å¾®è°ƒäº®ä¸€ç‚¹ç‚¹ï¼Œé…åˆæ¸…æ–°çš„ä¸»é¢˜ï¼Œä½†ä»ç„¶ä¿æŒæš—è°ƒä»¥çªå‡ºå…‰æ„Ÿ */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Montserrat', sans-serif; }
        #container { position: relative; width: 100vw; height: 100vh; background: radial-gradient(circle at center, #1a1a2e 0%, #000 100%); }
        
        #title-container {
            position: absolute; top: 12%; width: 100%; text-align: center; pointer-events: none; z-index: 10;
        }

        /* æ ‡é¢˜é…è‰²ä¹Ÿç¨å¾®å‘é¦™æ§Ÿé‡‘å’Œæ·¡é›…è‰²è°ƒé æ‹¢ */
        #main-title {
            font-family: 'ZCOOL XiaoWei', serif; font-size: 5.5rem; font-weight: normal; margin: 0; padding: 0 20px; letter-spacing: 0.15em;
            background: linear-gradient(to bottom, #fff 20%, #fdfcdc 40%, #e6c778 70%, #c0a060 90%);
            background-size: 100% 200%; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 5px rgba(255, 250, 220, 0.8));
            animation: titlePulse 4s ease-in-out infinite alternate, glowMove 8s linear infinite;
        }
        #main-title span {
            font-family: 'Playfair Display', serif; font-style: italic; font-weight: 900; font-size: 6rem; margin-right: 15px; letter-spacing: -0.05em; vertical-align: middle;
        }
        @keyframes titlePulse {
            from { transform: scale(1) translateY(0); filter: drop-shadow(0 0 5px rgba(255, 250, 220, 0.5)); }
            to { transform: scale(1.02) translateY(-5px); filter: drop-shadow(0 0 20px rgba(230, 199, 120, 0.8)); }
        }
        @keyframes glowMove { 0% { background-position: 0% 0%; } 100% { background-position: 0% 200%; } }

        #info-instructions {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.7); background: rgba(255,255,255,0.05); 
            padding: 14px 40px; border-radius: 50px; border: 1px solid rgba(255,215,0,0.2);
            backdrop-filter: blur(20px); font-size: 0.85rem; z-index: 100; letter-spacing: 2px;
        }
        
        /* å‡†å¿ƒæ ·å¼ */
        #reticle {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 40px; height: 40px; border: 1px solid rgba(255,250,220,0.5); /* æ›´æ·¡é›…çš„è¾¹æ¡† */
            border-radius: 50%; pointer-events: none; z-index: 50; display: none;
            transition: all 0.3s ease;
        }
        #reticle::before, #reticle::after {
            content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #fffadd; /* æ·¡é‡‘è‰²ä¸­å¿ƒ */
        }
        #reticle::before { width: 10px; height: 1px; }
        #reticle::after { width: 1px; height: 10px; }
        #reticle.active { width: 60px; height: 60px; border-color: #fff; background: rgba(255,255,255,0.1); }

        #video-input { display: none; }
    </style>
</head>
<body>
    <div id="reticle"></div>
    <div id="title-container">
        <h1 id="main-title"><span>2026</span>å…ƒæ—¦å¿«ä¹</h1>
    </div>
    <div id="container">
        <div id="info-instructions">æ­£åœ¨å¯åŠ¨å½±åƒè£…ç½®...</div>
        <video id="video-input" playsinline></video>
    </div>

    <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
    <script src="https://unpkg.com/@mediapipe/hands/hands.js"></script>
    <script src="https://unpkg.com/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particleSystem, mainGroup, snowSystem, imageGroup;
        let treePos = [], starPos = [], currentPos = [], targetColors = [], currentColors = [];
        let morphFactor = 0, targetMorph = 0, targetRotX = 0, targetRotY = 0;
        let zoomedImage = null, selectedImage = null;

        const COUNT = 5500; // ç¨å¾®å¢åŠ ç‚¹ç²’å­ç»™èœ¡çƒ›
        const IMG_COUNT = 10;

        function createStarTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            // æ›´æ¸…é€ã€æ´ç™½çš„å…‰æ™•ï¼Œé€‚åˆæ·¡é›…ä¸»é¢˜
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.3, 'rgba(255,250,240,0.8)');
            grad.addColorStop(0.6, 'rgba(255,245,230,0.2)');
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 55;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            mainGroup = new THREE.Group();
            scene.add(mainGroup);

            // ç…§ç‰‡å¢™ (ä¿æŒä¸å˜)
            imageGroup = new THREE.Group();
            mainGroup.add(imageGroup);
            const loader = new THREE.TextureLoader();
            for(let i=1; i<=IMG_COUNT; i++) {
                const texture = loader.load(`./mj/${i}.jpg`, (tex) => {
                    const aspect = tex.image.width / tex.image.height;
                    mesh.geometry = new THREE.PlaneGeometry(7 * aspect, 7);
                });
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0, side: THREE.DoubleSide, depthTest: true });
                const mesh = new THREE.Mesh(new THREE.PlaneGeometry(6, 9), material);
                const angle = ((i-1) / IMG_COUNT) * Math.PI * 2;
                mesh.position.set(Math.cos(angle) * 22, 0, Math.sin(angle) * 22);
                mesh.lookAt(0, 0, 0); 
                mesh.userData = { originalPos: mesh.position.clone(), originalRot: mesh.rotation.clone() };
                imageGroup.add(mesh);
            }

            // --- å…¨æ–°å®šä¹‰çš„æ·¡é›…è›‹ç³•ç»“æ„ä¸é…è‰² ---
            const geo = new THREE.BufferGeometry();
            const posArr = new Float32Array(COUNT * 3);
            const colArr = new Float32Array(COUNT * 3);
            const sizeArr = new Float32Array(COUNT);
            const tiers = [{ r: 13, h: 5, y: -11 }, { r: 9.5, h: 5, y: -5 }, { r: 6, h: 5, y: 1 }];
            
            // ã€æ ¸å¿ƒä¿®æ”¹ã€‘å…¨æ–°çš„æ·¡é›…æ¸…æ–°é…è‰²ç›˜
            const palette = {
                cakeBase: new THREE.Color(0xFFFFF0),   // è±¡ç‰™ç™½åŸºåº•
                cakeShadow: new THREE.Color(0xF0EAD6), // å¥¶æ²¹è‰²é˜´å½±
                accentPink: new THREE.Color(0xFFC1CC), // æŸ”å’Œæ·¡ç²‰ (ç é“¾)
                accentGreen: new THREE.Color(0xC1F0D0),// æ¸…æ–°è–„è·ç»¿ (ç‚¹ç¼€)
                champagne: new THREE.Color(0xE6C778),  // é¦™æ§Ÿé‡‘ (æŸ±å­)
                candleBody: new THREE.Color(0xFFFFFF), // æ´ç™½çƒ›èº«
                candleFlame: new THREE.Color(0xFF8C00),// çƒ›å…‰æ©™
                flameCore: new THREE.Color(0xFFD700)   // çƒ›å…‰é»„æ ¸å¿ƒ
            };

            // å®šä¹‰èœ¡çƒ›ä½ç½®
            const candlePositions = [];
            // åœ¨ä¸­å±‚å¹³å°çš„è¾¹ç¼˜æ”¾ç½® 6 æ”¯
            for(let k=0; k<6; k++) {
                const angle = (k/6) * Math.PI*2;
                candlePositions.push({ x: tiers[1].r * 0.9 * Math.cos(angle), y: tiers[1].y + tiers[1].h, z: tiers[1].r * 0.9 * Math.sin(angle) });
            }
            // åœ¨é¡¶å±‚ä¸­å¿ƒæ”¾ç½® 3 æ”¯ç°‡æ‹¥
            for(let k=0; k<3; k++) {
                const angle = (k/3) * Math.PI*2 + 0.5;
                candlePositions.push({ x: tiers[2].r * 0.4 * Math.cos(angle), y: tiers[2].y + tiers[2].h, z: tiers[2].r * 0.4 * Math.sin(angle) });
            }


            for(let i=0; i<COUNT; i++) {
                let vTree = new THREE.Vector3();
                let pColor = new THREE.Color();
                let pSize = 0.6;
                let angle = Math.random() * Math.PI * 2;

                if (i < 1000) { // --- æŸ”ç¾ç é“¾ (æ·¡ç²‰/è–„è·ç»¿) ---
                    const tierIdx = i < 500 ? 0 : 1;
                    const progress = ((i % 500) % 62) / 62;
                    const r = THREE.MathUtils.lerp(tiers[tierIdx].r, tiers[tierIdx+1].r, progress) * 1.03;
                    const drape = Math.sin(progress * Math.PI) * 2.2; 
                    vTree.set(r * Math.cos(angle), tiers[tierIdx].y + 4.8 - drape, r * Math.sin(angle));
                    // æ·¡ç²‰è‰²ä¸ºä¸»ï¼Œæ··å…¥ä¸€ç‚¹è–„è·ç»¿
                    pColor.lerpColors(palette.accentPink, palette.accentGreen, Math.random() * 0.4);
                    pSize = 0.5;
                } 
                else if (i < 1600) { // --- é¦™æ§Ÿé‡‘æ”¯æŸ± ---
                    const pillarIdx = Math.floor((i - 1000) / 75);
                    angle = (pillarIdx / 8) * Math.PI * 2;
                    vTree.set(9.6 * Math.cos(angle), -11 + Math.random() * 17, 9.6 * Math.sin(angle));
                    pColor.copy(palette.champagne);
                    pSize = 0.7;
                }
                else if (i < 2200) { // --- ã€æ–°å¢ã€‘æ¸©é¦¨çƒ›å…‰ ---
                    const candleIdx = Math.floor((i - 1600) / (600 / candlePositions.length));
                    const pos = candlePositions[candleIdx % candlePositions.length];
                    const particleType = Math.random(); // å†³å®šæ˜¯çƒ›èº«è¿˜æ˜¯çƒ›ç«

                    if (particleType > 0.15) { // çƒ›èº« (ç™½è‰²åœ†æŸ±)
                        const h = Math.random() * 2.5; // çƒ›èº«é«˜åº¦
                        const r = Math.random() * 0.4; // çƒ›èº«åŠå¾„
                        vTree.set(pos.x + r*Math.cos(angle), pos.y + h, pos.z + r*Math.sin(angle));
                        pColor.copy(palette.candleBody);
                        pSize = 0.5;
                    } else { // çƒ›ç« (é¡¶éƒ¨äº®æ–‘)
                        vTree.set(pos.x + (Math.random()-0.5)*0.2, pos.y + 2.6 + Math.random()*0.4, pos.z + (Math.random()-0.5)*0.2);
                        // çƒ›ç«æ ¸å¿ƒé»„åˆ°å¤–ç„°æ©™çš„æ¸å˜
                        pColor.lerpColors(palette.flameCore, palette.candleFlame, Math.random());
                        pSize = 1.0 + Math.random() * 0.5; // çƒ›ç«æ›´å¤§æ›´äº®
                    }
                }
                else { // --- è±¡ç‰™ç™½è›‹ç³•ä¸»ä½“ ---
                    let t = i < COUNT * 0.7 ? tiers[0] : (i < COUNT * 0.9 ? tiers[1] : tiers[2]);
                    const r = t.r * (0.92 + Math.random() * 0.08);
                    const hRel = Math.random();
                    vTree.set(r * Math.cos(angle), t.y + hRel * t.h, r * Math.sin(angle));
                    // è±¡ç‰™ç™½åŸºåº•ï¼Œå¸¦æœ‰æ·¡æ·¡çš„å¥¶æ²¹é˜´å½±ï¼Œå¢åŠ ç«‹ä½“æ„Ÿ
                    pColor.lerpColors(palette.cakeShadow, palette.cakeBase, hRel * 0.6 + 0.4);
                    pSize = 0.6 + Math.random()*0.3;

                    // éšæœºç‚¹ç¼€ä¸€äº›æ·¡ç²‰è‰²å’Œé¦™æ§Ÿè‰²çš„ç³–ç 
                    if (Math.random() > 0.96) {
                        pColor.copy(Math.random() > 0.5 ? palette.accentPink : palette.champagne);
                        pSize = 0.9;
                    }
                }

                treePos.push(vTree);
                // æ˜Ÿç©ºæ•£å¼€æ—¶ä¹Ÿç”¨æ›´æ¸…é€çš„é¢œè‰²
                starPos.push(new THREE.Vector3().setFromSphericalCoords(40 + Math.random()*30, Math.random()*Math.PI, Math.random()*Math.PI*2));
                currentPos.push(vTree.clone());
                colArr[i*3] = pColor.r; colArr[i*3+1] = pColor.g; colArr[i*3+2] = pColor.b;
                sizeArr[i] = pSize;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
            geo.setAttribute('size', new THREE.BufferAttribute(sizeArr, 1));

            particleSystem = new THREE.Points(geo, new THREE.PointsMaterial({ 
                size: 1.0, map: createStarTexture(), transparent: true, blending: THREE.AdditiveBlending, 
                vertexColors: true, depthWrite: false, sizeAttenuation: true 
            }));
            mainGroup.add(particleSystem);

            // é›ªèŠ± (æ›´åŠ æ´ç™½æ¸…é€)
            const snowGeo = new THREE.BufferGeometry();
            const snowPosArr = new Float32Array(800 * 3);
            for(let i=0; i<800*3; i++) snowPosArr[i] = (Math.random()-0.5)*150;
            snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPosArr, 3));
            scene.add(new THREE.Points(snowGeo, new THREE.PointsMaterial({ size: 0.3, color: 0xffffff, transparent: true, opacity: 0.35 })));

            animate();
        }

        const raycaster = new THREE.Raycaster();
        const centerScreen = new THREE.Vector2(0, 0);

        function animate() {
            requestAnimationFrame(animate);
            const now = Date.now();
            morphFactor = THREE.MathUtils.lerp(morphFactor, targetMorph, 0.05);
            mainGroup.rotation.y += 0.002;
            mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, targetRotY, 0.05);
            mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, targetRotX, 0.05);

            const isOpened = morphFactor > 0.4;
            const reticleEl = document.getElementById('reticle');
            reticleEl.style.display = isOpened ? 'block' : 'none';

            // è‡ªåŠ¨èšç„¦é€»è¾‘
            if (isOpened) {
                raycaster.setFromCamera(centerScreen, camera);
                const intersects = raycaster.intersectObjects(imageGroup.children);
                if (intersects.length > 0) {
                    selectedImage = intersects[0].object;
                    zoomedImage = selectedImage; 
                    reticleEl.classList.add('active');
                } else {
                    selectedImage = null;
                    zoomedImage = null;
                    reticleEl.classList.remove('active');
                }
            } else {
                zoomedImage = null;
            }

            imageGroup.children.forEach((mesh) => {
                if (zoomedImage === mesh) {
                    mesh.position.lerp(new THREE.Vector3(0, 0, 40), 0.12);
                    mesh.rotation.set(0, 0, 0);
                    mesh.material.opacity = 1;
                    mesh.renderOrder = 999; 
                } else if (zoomedImage) {
                    mesh.material.opacity = THREE.MathUtils.lerp(mesh.material.opacity, 0, 0.1);
                } else {
                    mesh.material.opacity = THREE.MathUtils.lerp(0, 0.9, (morphFactor - 0.3) * 3);
                    mesh.scale.setScalar(THREE.MathUtils.clamp(morphFactor * 1.2, 0.01, 1.2));
                    mesh.position.lerp(mesh.userData.originalPos, 0.08);
                    mesh.rotation.copy(mesh.userData.originalRot);
                    mesh.renderOrder = 0;
                }
            });

            const posAttr = particleSystem.geometry.attributes.position;
            for(let i=0; i<COUNT; i++) {
                currentPos[i].lerpVectors(treePos[i], starPos[i], morphFactor);
                posAttr.array[i*3] = currentPos[i].x;
                
                // çƒ›ç«çš„ç‰¹æ®Šå‘¼å¸æ•ˆæœ (index 2050-2200 å·¦å³æ˜¯çƒ›ç«)
                let breathing = Math.sin(now*0.001+i)*0.02;
                if (i > 2050 && i < 2200 && morphFactor < 0.3) {
                     breathing = Math.sin(now*0.005+i)*0.05; // çƒ›ç«é—ªçƒæ›´å¿«æ›´æ˜æ˜¾
                }
                posAttr.array[i*3+1] = currentPos[i].y + breathing;
                posAttr.array[i*3+2] = currentPos[i].z;
            }
            posAttr.needsUpdate = true;
            renderer.render(scene, camera);
        }

        async function startAI() {
            const info = document.getElementById('info-instructions');
            const hands = new Hands({ locateFile: (file) => `https://unpkg.com/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
            
            hands.onResults(res => {
                if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                    const h = res.multiHandLandmarks[0];
                    const fingers = [8, 12, 16, 20];
                    let openCount = 0;
                    fingers.forEach(tip => { if (h[tip].y < h[tip-2].y) openCount++; });
                    
                    targetMorph = openCount / 4;
                    targetRotY = (0.5 - h[9].x) * 10;
                    targetRotX = (h[9].y - 0.5) * 5;

                    if (zoomedImage) {
                        info.innerHTML = "âœ¨ å½±åƒèšç„¦ä¸­ | ç§»å¼€å‡†å¿ƒæˆ–å¼ å¼€æ‰‹æŒè¿”å›";
                    } else if (morphFactor > 0.4) {
                        info.innerHTML = "ğŸ¯ ç§»åŠ¨å‡†å¿ƒå¯¹å‡†ç…§ç‰‡ï¼Œå³å¯è‡ªåŠ¨æ”¾å¤§æŸ¥çœ‹";
                    } else {
                        info.innerHTML = "ğŸ–ï¸ æ…¢æ…¢å¼ å¼€æ‰‹æŒï¼Œå”¤é†’æ–°å¹´è®°å¿†";
                    }
                } else {
                    info.innerText = "âœ¨ è¯·å±•ç¤ºæ‰‹æŒä»¥å¼€å§‹äº¤äº’";
                }
            });

            const cam = new Camera(document.getElementById('video-input'), {
                onFrame: async () => { await hands.send({ image: document.getElementById('video-input') }); },
                width: 640, height: 480
            });
            cam.start();
        }

        window.onload = () => { init(); startAI(); };
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
