<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>2026 Private Gallery</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@1,400;1,700&family=Syncopate:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* 强制覆盖所有边距，防止滚动 */
        * { box-sizing: border-box; }
        html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background: #000; position: fixed; }
        
        /* 画布强制撑满并固定 */
        canvas { 
            position: absolute; top: 0; left: 0;
            width: 100vw !important; height: 100vh !important;
            display: block; filter: contrast(1.1) saturate(1.2); 
        }
        
        #ui { 
            position: absolute; top: 40%; left: 50%; 
            transform: translate(-50%, -50%); width: 100%; text-align: center; 
            pointer-events: none; z-index: 5; transition: opacity 0.5s ease;
        }
        .year-display {
            font-size: 20vw; font-weight: 700; color: rgba(255, 255, 255, 0.15);
            -webkit-text-stroke: 1px rgba(255, 215, 0, 0.2); margin: 0;
        }
        .sub-title {
            font-family: 'Playfair Display', serif; font-style: italic; font-size: 5vw;
            color: rgba(255, 255, 255, 0.4); margin-top: 10px;
        }
        #status {
            position: absolute; bottom: calc(40px + env(safe-area-inset-bottom)); 
            left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.4); font-size: 0.7rem; letter-spacing: 2px; z-index: 10;
        }
        video { display: none; }
    </style>
</head>
<body>
    <div id="ui"><h1 class="year-display">2026</h1><div class="sub-title">Happy New Year</div></div>
    <div id="status">TAP TO START</div>
    <canvas id="c"></canvas>
    <video id="v" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const folderName = "mj"; 
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        let w, h, dpr, photos = [], particles = [], rockets = [];
        let isStarMode = false, isPinching = false, handX = 0.5, handY = 0.5;
        let zoomLerp = 0, currentFocusIndex = 0, galaxyTime = 0;

        // 重新定义的 Resize 函数，彻底解决偏移
        function resize() {
            w = window.innerWidth;
            h = window.innerHeight;
            dpr = window.devicePixelRatio || 1;
            canvas.width = w * dpr;
            canvas.height = h * dpr;
            // 关键：重置并应用 DPR 缩放
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        // 优化后的 3D 投影函数，确保在手机正中心
        function project(x, y, z, rx, ry) {
            let x1 = x * Math.cos(ry) - z * Math.sin(ry);
            let z1 = x * Math.sin(ry) + z * Math.cos(ry);
            let y2 = y * Math.cos(rx) - z1 * Math.sin(rx);
            let z2 = y * Math.sin(rx) + z1 * Math.cos(rx);
            
            // 手机竖屏专用视角焦距
            const fov = h * 0.8; 
            const s = fov / (fov + z2 + 600); 
            return { x: x1 * s + w / 2, y: y2 * s + h / 2, s };
        }

        class Particle {
            constructor(x, y, z, hue) {
                this.x = x; this.y = y; this.z = z; this.hue = hue;
                this.angle = Math.random() * Math.PI * 2;
                this.radius = 200 + Math.random() * 600;
                this.alpha = 1; this.decay = 0.01 + Math.random() * 0.02;
                this.vx = (Math.random()-0.5)*15; this.vy = (Math.random()-0.5)*15; this.vz = (Math.random()-0.5)*15;
            }
            update() {
                if (isStarMode) {
                    this.angle += 0.005;
                    this.x += (Math.cos(this.angle) * this.radius - this.x) * 0.05;
                    this.z += (Math.sin(this.angle) * this.radius - this.z) * 0.05;
                    this.alpha = 0.6;
                } else {
                    this.vx *= 0.96; this.vy *= 0.96; this.vz *= 0.96; this.vy += 0.15;
                    this.x += this.vx; this.y += this.vy; this.z += this.vz;
                    this.alpha -= this.decay;
                }
            }
            draw(rx, ry) {
                if (this.alpha <= 0) return;
                const p = project(this.x, this.y, this.z, rx, ry);
                ctx.fillStyle = `hsla(${this.hue}, 80%, 70%, ${this.alpha})`;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.s * 2, 0, Math.PI * 2); ctx.fill();
            }
        }

        class Rocket {
            constructor() {
                this.x = (Math.random()-0.5)*400; this.y = h; this.z = (Math.random()-0.5)*400;
                this.targetY = -100 - Math.random()*300; this.hue = Math.random()*50;
            }
            update() { this.y -= 18; if (this.y <= this.targetY) { this.explode(); return true; } }
            draw(rx, ry) {
                const p = project(this.x, this.y, this.z, rx, ry);
                ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, Math.PI * 2); ctx.fill();
            }
            explode() { for(let i=0; i<80; i++) particles.push(new Particle(this.x, this.y, this.z, this.hue)); }
        }

        function animate() {
            ctx.globalCompositeOperation = 'source-over';
            ctx.fillStyle = `rgba(0,0,5,${0.2 + zoomLerp*0.2})`;
            ctx.fillRect(0, 0, w, h);
            
            const rx = (handY - 0.5) * 0.5 * (1-zoomLerp);
            const ry = (handX - 0.5) * 0.5 * (1-zoomLerp);

            ctx.globalCompositeOperation = 'lighter';
            if (!isStarMode && Math.random() < 0.05) rockets.push(new Rocket());
            rockets = rockets.filter(r => { r.draw(rx, ry); return !r.update(); });
            particles = particles.filter(p => { p.update(); p.draw(rx, ry); return p.alpha > 0; });

            if (isStarMode && photos.length > 0) {
                ctx.globalCompositeOperation = 'source-over';
                zoomLerp += ((isPinching ? 1 : 0) - zoomLerp) * 0.1;
                let targetIdx = handX * photos.length;
                currentFocusIndex += (targetIdx - currentFocusIndex) * 0.1;

                photos.forEach((pData, i) => {
                    let diff = Math.abs(i - currentFocusIndex);
                    let focus = Math.max(0, 1 - diff * 0.6);
                    let active = Math.abs(i - Math.round(currentFocusIndex)) < 0.5;
                    
                    ctx.globalAlpha = (0.2 + focus * 0.8) * (1-zoomLerp) + (active ? zoomLerp : 0);
                    let zOff = 200 + (active ? zoomLerp * 400 : 0);
                    let p = project(pData.x * (1-focus*0.5), 0, pData.z * (1-focus*0.5) + zOff, rx, ry);
                    
                    let sw = pData.img.width * p.s * (0.4 + focus * 0.6 + (active ? zoomLerp : 0)) * 0.5;
                    let sh = pData.img.height * p.s * (0.4 + focus * 0.6 + (active ? zoomLerp : 0)) * 0.5;
                    ctx.drawImage(pData.img, p.x - sw/2, p.y - sh/2, sw, sh);
                });
            }
            ctx.globalAlpha = 1;
            requestAnimationFrame(animate);
        }

        async function setup() {
            const hands = new Hands({locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
            hands.setOptions({maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5});
            hands.onResults(res => {
                if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                    const lm = res.multiHandLandmarks[0];
                    handX = 1 - lm[9].x; handY = lm[9].y;
                    isStarMode = Math.hypot(lm[12].x-lm[0].x, lm[12].y-lm[0].y) > 0.4;
                    isPinching = isStarMode && Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y) < 0.05;
                    document.getElementById('status').innerText = isStarMode ? (isPinching ? "ZOOMING" : "GALLERY") : "FIREWORKS";
                }
            });
            const cam = new Camera(document.getElementById('v'), {
                onFrame: async () => { await hands.send({image: document.getElementById('v')}); },
                width: 480, height: 640
            });
            window.addEventListener('touchstart', () => cam.start(), {once: true});
        }

        resize();
        window.addEventListener('resize', resize);
        for(let i=1; i<=13; i++) {
            const img = new Image(); img.crossOrigin = "anonymous";
            img.src = `${folderName}/${i}.jpg`;
            img.onload = () => {
                const ang = (i/13) * Math.PI * 2;
                photos.push({img, x: Math.cos(ang)*500, z: Math.sin(ang)*500});
                if (photos.length === 13) { setup(); animate(); }
            };
        }
    </script>
</body>
</html>
